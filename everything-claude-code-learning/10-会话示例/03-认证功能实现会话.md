<!--
【教学目标】

本示例展示如何使用 Claude Code 进行功能实现会话。

学习要点：
1. 如何记录复杂功能的实现过程
2. 如何记录遇到的技术障碍和解决方案
3. 如何记录重要的技术决策和理由
4. 使用时间线日志记录开发进展

适用场景：
- 新功能开发
- 需要多步骤实现的任务
- 涉及多个文件的功能开发

【Claude Code 使用技巧】

1. 用"进行中"清单追踪未完成任务
2. 详细记录遇到的阻碍（Blockers）
3. 保存技术决策的背景和理由
4. 列出所有修改的代码位置
5. 使用时间线日志记录每一步进展
6. 记录代码片段的前后对比

-->

# 会话：认证功能实现
**日期：** 2026-01-20
**开始时间：** 14:30
**最后更新：** 17:45

---

## 当前状态

正在为API实现JWT认证流程。主要目标是用无状态令牌替换基于会话的认证。

### 已完成
- [x] 使用RS256设置JWT签名
- [x] 创建 `/auth/login` 端点
- [x] 添加刷新令牌轮换
- [x] 修复令牌过期bug（错误使用秒，需要毫秒）

### 进行中
- [ ] 为认证端点添加速率限制
- [ ] 实现退出登录的令牌黑名单

### 遇到的阻碍
1. **jsonwebtoken版本不匹配** - v9.x更改了`verify()`的签名，必须更新错误处理
2. **刷新令牌的Redis TTL** - 设置的TTL是秒但传入的是毫秒

### 关键技术决策
- 使用RS256而非HS256，以便在分布式服务中获得更好的安全性
- 将刷新令牌存储在Redis中，TTL为7天
- 访问令牌15分钟过期

### 修改的代码位置
- `src/middleware/auth.js` - JWT验证中间件
- `src/routes/auth.js` - 登录/退出/刷新端点
- `src/services/token.service.js` - 令牌生成和验证

### 下次会话的注意事项
- 需要为基于cookie的令牌存储添加CSRF保护
- 考虑为刷新令牌绑定添加指纹识别
- 与团队审查速率限制值

### 需要加载的上下文
src/middleware/
src/routes/auth.js
src/services/token.service.js

---

## 会话日志

**14:30** - 开始会话，目标是实现JWT

**14:45** - 设置基本JWT签名。使用RS256，密钥对存储在环境变量中。

**15:20** - 登录端点工作正常。发现jsonwebtoken v9的破坏性变更 - `verify()`现在抛出不同的错误类型。更新了catch块：
```javascript
// 旧版本（v8）
if (err.name === 'TokenExpiredError') { ... }

// 新版本（v9）
if (err instanceof jwt.TokenExpiredError) { ... }
```

**16:00** - 刷新令牌轮换工作正常，但令牌立即过期。Bug：向期望秒数的`expiresIn`传递了`Date.now()`（毫秒）。已修复：
```javascript
// 错误写法
expiresIn: Date.now() + 900000

// 正确写法
expiresIn: '15m'
```

**17:30** - 认证流程完成。登录 -> 访问令牌 -> 刷新 -> 新令牌。明天准备实现速率限制。

**17:45** - 保存会话状态。
