<!--
╔══════════════════════════════════════════════════════════════════╗
║  【教学概述】                                                      ║
╠══════════════════════════════════════════════════════════════════╣
║  模板用途：Go 微服务项目配置模板                                  ║
║  适合人群：使用 Go + gRPC + PostgreSQL 的微服务开发者             ║
║  核心要点：                                                        ║
║    - 清晰架构（领域、仓储、服务、处理层分离）                      ║
║    - sqlc 类型安全的 SQL 查询                                     ║
║    - gRPC + REST 双协议支持                                       ║
║    - Wire 依赖注入                                                ║
║    - 错误包装和上下文传递                                          ║
╚══════════════════════════════════════════════════════════════════╝
-->

# Go 微服务 — 项目 CLAUDE.md

> Go 微服务与 PostgreSQL、gRPC 和 Docker 的真实示例。
> 将此复制到你的项目根目录并为你的服务进行定制。

## 项目概述

**技术栈：** Go 1.22+、PostgreSQL、gRPC + REST（grpc-gateway）、Docker、sqlc（类型安全 SQL）、Wire（依赖注入）

**架构：** 具有领域、仓储、服务和处理层的清晰架构。gRPC 作为主要传输，REST 网关用于外部客户端。

## 关键规则

### Go 约定

- 遵循 Effective Go 和 Go Code Review Comments 指南
- 使用带 `%w` 的 `errors.New` / `fmt.Errorf` 进行包装 - 永远不要对错误进行字符串匹配
- 没有 `init()` 函数 - 在 `main()` 或构造函数中显式初始化
- 没有全局可变状态 - 通过构造函数传递依赖
- Context 必须是第一个参数并传播到所有层

### 数据库

- 所有查询在 `queries/` 中作为纯 SQL - sqlc 生成类型安全的 Go 代码
- 使用 golang-migrate 的 `migrations/` 中的迁移 - 永远不要直接修改数据库
- 通过 `pgx.Tx` 对多步操作使用事务
- 所有查询必须使用参数化占位符（`$1`、`$2`）- 永远不要字符串格式化

### 错误处理

- 返回错误，不要 panic - panic 仅用于真正无法恢复的情况
- 使用上下文包装错误：`fmt.Errorf("creating user: %w", err)`
- 在 `domain/errors.go` 中为业务逻辑定义哨兵错误
- 在处理层中将域错误映射到 gRPC 状态代码

```go
// 域层 - 哨兵错误
var (
    ErrUserNotFound  = errors.New("user not found")
    ErrEmailTaken    = errors.New("email already registered")
)

// 处理层 - 映射到 gRPC 状态
func toGRPCError(err error) error {
    switch {
    case errors.Is(err, domain.ErrUserNotFound):
        return status.Error(codes.NotFound, err.Error())
    case errors.Is(err, domain.ErrEmailTaken):
        return status.Error(codes.AlreadyExists, err.Error())
    default:
        return status.Error(codes.Internal, "internal error")
    }
}
```

### 代码风格

- 代码或注释中没有表情符号
- 导出的类型和函数必须有文档注释
- 保持函数在 50 行以下 - 提取辅助函数
- 对所有具有多个情况的逻辑使用表驱动测试
- 信号通道优先使用 `struct{}`，而不是 `bool`

## 文件结构

```
cmd/
  server/
    main.go              # 入口点、Wire 注入、优雅关闭
internal/
  domain/                # 业务类型和接口
    user.go              # User 实体和仓储接口
    errors.go            # 哨兵错误
  service/               # 业务逻辑
    user_service.go
    user_service_test.go
  repository/            # 数据访问（sqlc 生成 + 自定义）
    postgres/
      user_repo.go
      user_repo_test.go  # 使用 testcontainers 的集成测试
  handler/               # gRPC + REST 处理器
    grpc/
      user_handler.go
    rest/
      user_handler.go
  config/                # 配置加载
    config.go
proto/                   # Protobuf 定义
  user/v1/
    user.proto
queries/                 # sqlc 的 SQL 查询
  user.sql
migrations/              # 数据库迁移
  001_create_users.up.sql
  001_create_users.down.sql
```

## 关键模式

### 仓储接口

```go
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id uuid.UUID) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id uuid.UUID) error
}
```

### 带依赖注入的服务

```go
type UserService struct {
    repo   domain.UserRepository
    hasher PasswordHasher
    logger *slog.Logger
}

func NewUserService(repo domain.UserRepository, hasher PasswordHasher, logger *slog.Logger) *UserService {
    return &UserService{repo: repo, hasher: hasher, logger: logger}
}

func (s *UserService) Create(ctx context.Context, req CreateUserRequest) (*domain.User, error) {
    existing, err := s.repo.FindByEmail(ctx, req.Email)
    if err != nil && !errors.Is(err, domain.ErrUserNotFound) {
        return nil, fmt.Errorf("checking email: %w", err)
    }
    if existing != nil {
        return nil, domain.ErrEmailTaken
    }

    hashed, err := s.hasher.Hash(req.Password)
    if err != nil {
        return nil, fmt.Errorf("hashing password: %w", err)
    }

    user := &domain.User{
        ID:       uuid.New(),
        Name:     req.Name,
        Email:    req.Email,
        Password: hashed,
    }
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, fmt.Errorf("creating user: %w", err)
    }
    return user, nil
}
```

### 表驱动测试

```go
func TestUserService_Create(t *testing.T) {
    tests := []struct {
        name    string
        req     CreateUserRequest
        setup   func(*MockUserRepo)
        wantErr error
    }{
        {
            name: "valid user",
            req:  CreateUserRequest{Name: "Alice", Email: "alice@example.com", Password: "secure123"},
            setup: func(m *MockUserRepo) {
                m.On("FindByEmail", mock.Anything, "alice@example.com").Return(nil, domain.ErrUserNotFound)
                m.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: nil,
        },
        {
            name: "duplicate email",
            req:  CreateUserRequest{Name: "Alice", Email: "taken@example.com", Password: "secure123"},
            setup: func(m *MockUserRepo) {
                m.On("FindByEmail", mock.Anything, "taken@example.com").Return(&domain.User{}, nil)
            },
            wantErr: domain.ErrEmailTaken,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            repo := new(MockUserRepo)
            tt.setup(repo)
            svc := NewUserService(repo, &bcryptHasher{}, slog.Default())

            _, err := svc.Create(context.Background(), tt.req)

            if tt.wantErr != nil {
                assert.ErrorIs(t, err, tt.wantErr)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

## 环境变量

```bash
# 数据库
DATABASE_URL=postgres://user:pass@localhost:5432/myservice?sslmode=disable

# gRPC
GRPC_PORT=50051
REST_PORT=8080

# 认证
JWT_SECRET=           # 生产中从 vault 加载
TOKEN_EXPIRY=24h

# 可观察性
LOG_LEVEL=info        # debug, info, warn, error
OTEL_ENDPOINT=        # OpenTelemetry 收集器
```

## 测试策略

```bash
/go-test             # Go 的 TDD 工作流
/go-review           # Go 特定代码审查
/go-build            # 修复构建错误
```

### 测试命令

```bash
# 单元测试（快速，无外部依赖）
go test ./internal/... -short -count=1

# 集成测试（需要 Docker 用于 testcontainers）
go test ./internal/repository/... -count=1 -timeout 120s

# 所有测试带覆盖率
go test ./... -coverprofile=coverage.out -count=1
go tool cover -func=coverage.out  # 摘要
go tool cover -html=coverage.out  # 浏览器

# 竞态检测器
go test ./... -race -count=1
```

## ECC 工作流

```bash
# 规划
/plan "为用户端点添加速率限制"

# 开发
/go-test                  # 使用 Go 特定模式的 TDD

# 审查
/go-review                # Go 惯用法、错误处理、并发
/security-scan            # 密钥和漏洞

# 合并前
go vet ./...
staticcheck ./...
```

## Git 工作流

- `feat:` 新功能，`fix:` 错误修复，`refactor:` 代码更改
- 从 `main` 创建功能分支，需要 PR
- CI：`go vet`、`staticcheck`、`go test -race`、`golangci-lint`
- 部署：CI 中构建的 Docker 镜像，部署到 Kubernetes
