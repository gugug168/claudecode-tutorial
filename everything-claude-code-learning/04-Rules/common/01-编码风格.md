# 编码风格 (Coding Style)

> **规则用途**：定义通用编码风格和代码质量标准
>
> **适用场景**：编写代码时、代码审查时参考
>
> **核心能力**：不可变性、文件组织、错误处理、输入验证、质量检查清单
>
> **适用范围**：通用规则（适用于所有语言）

---

## 不可变性 (Immutability) - 关键原则

### 什么是不可变性？

不可变性是指一旦创建对象后，就不再修改它。如果需要改变数据，就创建一个新的对象。

### 为什么重要？

想象你在写一份报告：
- **错误做法**：直接在原报告上涂改（容易出错，难以追溯）
- **正确做法**：复制一份报告，在新版本上修改（保留历史，清晰明了）

代码中也是如此：
- **防止隐藏副作用**：不知道哪个函数修改了数据
- **调试更容易**：数据变化有迹可循
- **支持并发安全**：多个线程访问同一数据不会冲突

### 如何实践

```javascript
// 错误示例：直接修改原对象
function modifyUser(user) {
  user.name = "New Name";  // 修改了原对象
  return user;
}

// 正确示例：创建新对象
function updateUser(user) {
  return {
    ...user,           // 复制原对象
    name: "New Name"   // 覆盖需要修改的字段
  };
}
```

### 实践建议

| 操作 | 推荐做法 | 避免做法 |
|------|----------|----------|
| 修改对象 | 创建新副本 | 直接修改属性 |
| 添加数组元素 | `[...arr, newItem]` | `arr.push(newItem)` |
| 删除数组元素 | `arr.filter(item => item.id !== id)` | `arr.splice(index, 1)` |
| 更新数组元素 | `arr.map(item => item.id === id ? {...item, ...changes} : item)` | 直接赋值修改 |

---

## 文件组织 (File Organization)

### 核心原则

**多文件优于少文件**（MANY SMALL FILES > FEW LARGE FILES）

为什么？想象整理文件柜：
- 一个抽屉塞满100张纸 vs 分成10个文件夹
- 小文件更容易理解、维护和查找

### 文件大小指南

| 类型 | 推荐行数 | 最大限制 |
|------|----------|----------|
| 普通文件 | 200-400 行 | 800 行 |
| 工具函数 | 100-200 行 | 500 行 |
| 配置文件 | 尽量小 | 300 行 |
| 测试文件 | 与源文件相当 | 1000 行 |

### 组织策略

1. **按功能/领域组织**（推荐）
   ```
   src/
   ├── user/
   │   ├── user.service.ts
   │   ├── user.model.ts
   │   └── user.repository.ts
   └── auth/
       ├── auth.service.ts
       └── auth.middleware.ts
   ```

2. **不要按类型组织**（不推荐）
   ```
   src/
   ├── services/     // 所有服务混在一起
   ├── models/       // 所有模型混在一起
   └── repositories/ // 所有仓库混在一起
   ```

### 何时拆分文件？

- 单个文件超过 400 行
- 单个函数超过 50 行
- 文件包含多个不相关的功能
- 多人频繁修改同一文件的不同部分

---

## 错误处理 (Error Handling)

### 错误处理金字塔

```
              用户界面
                ↓
          友好的错误提示
                ↓
            业务逻辑层
                ↓
          详细错误日志
                ↓
            技术细节
```

### 完整的错误处理流程

#### 1. 每一层都要显式处理错误

```javascript
// 好的做法
async function getUserById(id) {
  try {
    const user = await database.findUser(id);
    if (!user) {
      throw new NotFoundError(`User ${id} not found`);
    }
    return user;
  } catch (error) {
    logger.error('Database error in getUserById', {
      userId: id,
      error: error.message,
      stack: error.stack
    });
    throw error; // 重新抛出给上层处理
  }
}

// 坏的做法：静默吞掉错误
async function getUserById(id) {
  try {
    return await database.findUser(id);
  } catch (error) {
    // 什么都不做，返回 undefined
    return null;
  }
}
```

#### 2. 面向用户的错误消息

```javascript
// 前端示例
try {
  await api.updateProfile(data);
} catch (error) {
  if (error.type === 'VALIDATION_ERROR') {
    // 显示具体的验证错误
    showErrorMessage(`请检查您的输入：${error.details}`);
  } else if (error.type === 'NETWORK_ERROR') {
    // 显示友好的网络错误
    showErrorMessage('网络连接失败，请稍后重试');
  } else {
    // 通用错误消息（不暴露技术细节）
    showErrorMessage('操作失败，请稍后重试');
  }
}
```

#### 3. 服务端详细日志

```javascript
// 后端示例
app.use((err, req, res, next) => {
  // 记录详细错误信息
  logger.error('Request error', {
    url: req.url,
    method: req.method,
    userId: req.user?.id,
    errorName: err.name,
    errorMessage: err.message,
    errorStack: err.stack,
    timestamp: new Date().toISOString()
  });

  // 返回友好的错误消息给用户
  res.status(err.status || 500).json({
    success: false,
    message: err.userMessage || '服务器错误，请稍后重试'
  });
});
```

### 错误处理检查清单

- [ ] 每个函数都有错误处理
- [ ] 错误不会静默消失
- [ ] 用户看到友好的错误消息
- [ ] 开发者能看到详细的错误日志
- [ ] 错误包含足够的上下文信息

---

## 输入验证 (Input Validation)

### 为什么需要验证？

想象开门的情景：
- 你不会随便什么人敲门就开门
- 你会先确认对方是谁
- 然后决定是否开门

代码也是一样：
- 不要信任任何外部数据
- 在系统边界验证所有输入
- 验证失败则快速拒绝

### 何时验证？

```
外部世界 → 验证边界 → 你的代码
  ↑         ↑         ↑
用户输入   检查所有   安全
API响应   字段      可信
文件内容   拒绝无效
```

### 验证策略

#### 1. Schema 验证（推荐）

```javascript
// 使用 Zod 进行 schema 验证
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email('邮箱格式不正确'),
  age: z.number().min(18, '必须年满18岁').max(120, '年龄无效'),
  name: z.string().min(2, '姓名至少2个字符').max(50, '姓名最多50个字符')
});

function createUser(input) {
  // 验证输入
  const validated = userSchema.parse(input);

  // 如果验证失败，这里会抛出详细的错误
  // 只有通过验证的数据才会继续处理

  return database.createUser(validated);
}
```

#### 2. 快速失败原则

```javascript
// 好的做法：立即验证并失败
function processPayment(paymentData) {
  // 验证在函数开始就进行
  if (!paymentData.amount || paymentData.amount <= 0) {
    throw new ValidationError('金额必须大于0');
  }

  if (!paymentData.currency) {
    throw new ValidationError('必须指定货币类型');
  }

  // 如果验证通过，继续处理
  // ...
}

// 坏的做法：验证分散在各处
function processPayment(paymentData) {
  // 做一些处理...
  const result = calculate(paymentData.amount);

  // 在这里才发现金额无效
  if (result <= 0) {
    throw new Error('计算失败');
  }
}
```

### 验证检查清单

| 数据类型 | 验证项 | 示例 |
|----------|--------|------|
| 用户输入 | 格式、长度、范围 | 邮箱格式、密码长度 |
| API 响应 | 类型、必填字段 | 检查所有必填字段存在 |
| 文件内容 | 大小、类型、结构 | 图片大小限制、JSON 格式 |
| URL 参数 | 类型、范围 | 分页参数、ID 格式 |
| 环境变量 | 必需性、格式 | 数据库连接字符串 |

### 常见验证场景

```javascript
// 1. API 请求参数
app.post('/api/users', (req, res) => {
  const { name, email } = req.body;

  // 验证
  if (!name || name.length < 2) {
    return res.status(400).json({ error: '姓名至少2个字符' });
  }

  if (!email || !email.includes('@')) {
    return res.status(400).json({ error: '邮箱格式无效' });
  }

  // 验证通过，继续处理
});

// 2. 文件上传
app.post('/upload', upload.single('file'), (req, res) => {
  const file = req.file;

  // 验证文件类型
  if (!file.mimetype.startsWith('image/')) {
    return res.status(400).json({ error: '只支持图片文件' });
  }

  // 验证文件大小（例如：最大 5MB）
  if (file.size > 5 * 1024 * 1024) {
    return res.status(400).json({ error: '文件大小不能超过 5MB' });
  }

  // 验证通过，继续处理
});

// 3. 环境变量
function validateEnv() {
  const required = ['DATABASE_URL', 'JWT_SECRET', 'API_KEY'];

  for (const key of required) {
    if (!process.env[key]) {
      throw new Error(`缺少必需的环境变量: ${key}`);
    }
  }
}

// 应用启动时验证
validateEnv();
```

---

## 代码质量检查清单 (Code Quality Checklist)

### 提交代码前自检

#### 可读性

- [ ] 变量和函数名称清晰表达意图
  ```javascript
  // 好的命名
  const isAuthenticated = checkUserAuth(user);

  // 坏的命名
  const flag = check(u);
  ```

- [ ] 代码逻辑易于理解
  ```javascript
  // 好的做法：清晰的逻辑
  function canAccessResource(user, resource) {
    return user.isLoggedIn && user.hasPermission(resource.permission);
  }

  // 坏的做法：复杂的嵌套
  function canAccessResource(user, resource) {
    if (user) {
      if (user.isLoggedIn) {
        if (resource) {
          if (resource.permission) {
            return user.permissions.includes(resource.permission);
          }
        }
      }
    }
    return false;
  }
  ```

#### 函数大小

- [ ] 函数小于 50 行
- [ ] 单一职责原则（只做一件事）
- [ ] 参数不超过 5 个

#### 文件组织

- [ ] 文件小于 800 行
- [ ] 相关代码聚合在一起
- [ ] 无重复代码（DRY 原则）

#### 嵌套层次

- [ ] 嵌套不超过 4 层
  ```javascript
  // 好的做法：早期返回
  function processUser(user) {
    if (!user) {
      return null;
    }

    if (!user.isActive) {
      return null;
    }

    if (!user.hasPermission) {
      return null;
    }

    // 主逻辑
    return transformUser(user);
  }

  // 坏的做法：深层嵌套
  function processUser(user) {
    if (user) {
      if (user.isActive) {
        if (user.hasPermission) {
          // 主逻辑
          return transformUser(user);
        }
      }
    }
    return null;
  }
  ```

#### 错误处理

- [ ] 所有错误都被捕获
- [ ] 错误消息清晰明确
- [ ] 错误包含足够的上下文

#### 魔法数字

- [ ] 无硬编码的数字和字符串
  ```javascript
  // 好的做法：使用常量
  const MAX_RETRY_ATTEMPTS = 3;
  const DEFAULT_TIMEOUT = 5000; // 5 seconds

  if (attempts >= MAX_RETRY_ATTEMPTS) {
    setTimeout(retry, DEFAULT_TIMEOUT);
  }

  // 坏的做法：魔法数字
  if (attempts >= 3) {
    setTimeout(retry, 5000);
  }
  ```

#### 不可变性

- [ ] 不直接修改传入的参数
- [ ] 使用不可变操作处理数组和对象
- [ ] 避免使用会修改原数据的方法

### 代码审查速查表

| 检查项 | 通过标准 |
|--------|----------|
| 命名 | 见名知意，符合语言规范 |
| 长度 | 函数 < 50 行，文件 < 800 行 |
| 复杂度 | 圈复杂度 < 10 |
| 重复 | 无重复代码块 |
| 测试 | 有对应的测试用例 |
| 文档 | 复杂逻辑有注释说明 |

---

## 常见问题 (FAQ)

### Q1: 为什么不可变性会提高性能？

**答**：虽然创建新对象看似"浪费"内存，但实际上：
1. 现代 JavaScript 引擎对不可变数据有优化
2. 可以安全地共享数据结构
3. 避免了深拷贝的需要
4. 更容易实现高效的变更检测（React 就是例子）

### Q2: 文件太小会不会影响性能？

**答**：不会。现代打包工具（Webpack、Vite）会将多个小文件合并和优化。小文件的优势：
- 更容易理解和维护
- 减少合并冲突
- 提高代码复用性

### Q3: 如何平衡错误处理和代码简洁性？

**答**：
1. 使用统一的错误处理中间件
2. 提取通用的错误处理逻辑
3. 使用自定义错误类型
4. 在适当层级处理错误（不要到处捕获）

### Q4: 所有输入都需要验证吗？

**答**：是的，但可以分层：
- **边界验证**：API 入口、文件读取、用户输入
- **内部验证**：关键函数的参数验证
- **类型验证**：使用 TypeScript 在编译时捕获

---

## 总结

编码风格的核心原则：

| 原则 | 关键点 | 记忆口诀 |
|------|--------|----------|
| **不可变性** | 创建新对象而非修改旧对象 | 不改旧，只造新 |
| **小文件** | 200-400 行，按功能组织 | 小而美，聚功能 |
| **完整错误处理** | 每层处理，用户友好，日志详细 | 错误不吞，处处管 |
| **输入验证** | 边界验证，快速失败 | 验证先行，快速拒 |
| **质量检查** | 命名清晰，函数小，无深层嵌套 | 代码简洁，易读懂 |

遵循这些原则，你的代码将更健壮、更易维护、更易协作！
