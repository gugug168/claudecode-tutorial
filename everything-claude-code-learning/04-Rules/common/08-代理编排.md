# 代理编排 (Agent Orchestration)

> **规则用途**：定义代理编排和使用规范
>
> **适用场景**：需要调用子代理、并行执行任务时参考
>
> **核心能力**：代理列表、即时使用场景、并行执行、多视角分析
>
> **适用范围**：通用规则

---

## 可用代理 (Available Agents)

### 什么是代理（Agent）？

代理就像专业顾问团队：
- **Planner**：项目经理，负责规划
- **Architect**：系统架构师，负责设计
- **TDD-Guide**：测试专家，负责质量
- **Code-Reviewer**：代码审查员，负责检查
- **Security-Reviewer**：安全专家，负责防护
- **Build-Error-Resolver**：修复专家，负责排错

所有代理位于：`~/.claude/agents/`

### 代理列表与用途

| 代理 | 用途 | 何时使用 | 示例场景 |
|------|------|----------|----------|
| **planner** | 实现规划 | 复杂功能、重构 | "设计一个用户系统" |
| **architect** | 系统设计 | 架构决策 | "选择合适的数据库" |
| **tdd-guide** | 测试驱动开发 | 新功能、bug 修复 | "实现登录功能（TDD）" |
| **code-reviewer** | 代码审查 | 编写代码后 | "审查我刚写的代码" |
| **security-reviewer** | 安全分析 | 提交前 | "检查这个功能的安全性" |
| **build-error-resolver** | 修复构建错误 | 构建失败时 | "TypeScript 编译错误" |
| **e2e-runner** | E2E 测试 | 关键用户流程 | "测试完整的购物流程" |
| **refactor-cleaner** | 死代码清理 | 代码维护 | "清理未使用的代码" |
| **doc-updater** | 文档更新 | 更新文档 | "更新 API 文档" |

### 代理详细说明

#### 1. Planner（规划代理）

```markdown
职责：创建详细的实施计划

使用场景：
- 复杂功能的实现规划
- 大规模重构规划
- 技术方案评估

输入示例：
"规划一个用户认证系统的实现"

输出示例：
## 实施计划：用户认证系统

### 第一阶段：数据模型（2天）
- 设计 User 表结构
- 创建 User 实体类
- 实现 UserRepository

### 第二阶段：认证逻辑（3天）
- 实现密码加密
- 实现 JWT 生成和验证
- 创建 AuthService

### 第三阶段：API 端点（2天）
- POST /api/auth/register
- POST /api/auth/login
- GET /api/auth/me

### 第四阶段：测试和文档（2天）
- 单元测试
- 集成测试
- API 文档

**总计：9 天**
```

#### 2. Architect（架构代理）

```markdown
职责：系统设计和技术决策

使用场景：
- 架构设计
- 技术选型
- 设计模式选择

输入示例：
"设计一个高并发的订单系统"

输出示例：
## 系统架构设计

### 架构模式
- 微服务架构
- 事件驱动
- CQRS 模式

### 技术选型
- **API Gateway**: Kong
- **服务框架**: NestJS
- **数据库**: PostgreSQL (主库) + MongoDB (订单)
- **消息队列**: RabbitMQ
- **缓存**: Redis

### 扩展性设计
- 水平扩展：无状态服务
- 读写分离：主从数据库
- 缓存策略：多级缓存
- 限流降级：令牌桶算法
```

#### 3. TDD-Guide（测试驱动开发代理）

```markdown
职责：引导 TDD 开发流程

使用场景：
- 新功能开发
- Bug 修复
- 重构现有代码

工作流程：
1. RED - 编写失败的测试
2. GREEN - 实现功能让测试通过
3. IMPROVE - 重构优化

输入示例：
"使用 TDD 实现用户注册功能"

TDD-Guide 引导：
步骤 1：编写测试（RED）
创建 user.service.test.ts
describe('UserService.register', () => {
  it('should create new user', () => {
    // 测试代码
  });
});

运行测试：❌ 失败（预期）

步骤 2：实现功能（GREEN）
创建 user.service.ts
实现 register 方法

运行测试：✅ 通过

步骤 3：重构（IMPROVE）
提取常量、优化结构

运行测试：✅ 仍然通过
```

#### 4. Code-Reviewer（代码审查代理）

```markdown
职责：审查代码质量和最佳实践

使用场景：
- 代码编写后立即审查
- 提交 PR 前
- 代码重构前

审查维度：
- 代码风格
- 命名规范
- 错误处理
- 性能问题
- 安全隐患
- 测试覆盖

输出示例：
## 代码审查报告

### CRITICAL（必须修复）
🚨 密码明文存储
位置：auth.service.ts:45
建议：使用 bcrypt 加密

### HIGH（强烈建议）
⚠️ 缺少输入验证
位置：user.controller.ts:23
建议：添加 class-validator 装饰器

### MEDIUM（建议改进）
📝 函数过长
位置：order.service.ts:100
建议：拆分为更小的函数

### GOOD（做得好）
✅ 错误处理完善
✅ 使用了 TypeScript 类型
✅ 有单元测试
```

#### 5. Security-Reviewer（安全审查代理）

```markdown
职责：检查安全漏洞和风险

使用场景：
- 提交代码前
- 处理用户数据的功能
- API 端点开发

检查项目：
- SQL 注入
- XSS 攻击
- CSRF 防护
- 认证授权
- 敏感数据泄露
- 依赖包漏洞

输出示例：
## 安全审查报告

### 严重漏洞（CRITICAL）
🚨 SQL 注入风险
文件：user.repository.ts:30
代码：`SELECT * FROM users WHERE id = ${id}`
修复：使用参数化查询

### 高危风险（HIGH）
⚠️ 缺少 CSRF 保护
文件：forms.ts:15
建议：添加 CSRF token

### 中危风险（MEDIUM）
📝 错误消息泄露信息
文件：error.handler.ts:8
建议：使用通用错误消息

### 通过的安全检查
✅ 密码使用 bcrypt 加密
✅ API 有速率限制
✅ 使用了 JWT 认证
```

---

## 即时代理使用 (Immediate Agent Usage)

### 无需用户提示的场景

以下情况应自动调用相应代理，无需等待用户明确要求：

#### 1. 复杂功能请求 → Planner 代理

```typescript
// 检测到复杂请求
用户请求："实现一个完整的电商系统"

// 自动调用
/planner "分解电商系统的实现任务"

// Planner 输出详细计划
// 然后按计划逐步执行
```

#### 2. 代码刚编写/修改 → Code-Reviewer 代理

```typescript
// AI 刚完成代码编写
AI：完成了用户注册功能的实现

// 自动调用
/code-reviewer "审查刚实现的用户注册代码"

// Code-Reviewer 提供反馈
// 根据反馈修复问题
```

#### 3. Bug 修复或新功能 → TDD-Guide 代理

```typescript
// 检测到功能开发请求
用户请求："添加密码重置功能"

// 自动调用
/tdd-guide "使用 TDD 实现密码重置功能"

// TDD-Guide 引导整个开发流程
// 确保有完善的测试
```

#### 4. 架构决策 → Architect 代理

```typescript
// 检测到架构问题
用户请求："如何在微服务间共享数据？"

// 自动调用
/architect "设计微服务数据共享方案"

// Architect 提供架构建议
// 包括技术选型和实现方案
```

### 即时使用决策表

| 触发条件 | 自动调用代理 | 延迟原因 |
|----------|-------------|----------|
| 复杂功能（>5 个步骤） | planner | 需要先规划 |
| 代码修改完成 | code-reviewer | 立即审查 |
| 新功能开发 | tdd-guide | 确保测试先行 |
| 架构问题 | architect | 需要专业设计 |
| 构建失败 | build-error-resolver | 快速修复 |
| 安全相关功能 | security-reviewer | 安全第一 |

---

## 并行任务执行

### 为什么需要并行执行？

想象装修房子：
```
串行（慢）：
第 1 周：水电工
第 2 周：木工
第 3 周：油漆工
第 4 周：完成
总计：4 周

并行（快）：
第 1-2 周：水电工（客厅） + 木工（卧室）
第 3-4 周：油漆工（全屋）
总计：2 周
```

代码任务也是一样：
- **独立任务**：可以并行执行
- **依赖任务**：必须串行执行

### 并行执行示例

#### 好的做法：并行启动多个代理

```markdown
# 同时执行多个独立任务

用户："全面审查这个项目"

AI 响应：
我将并行启动 3 个代理进行审查：

1. 🔍 代码质量审查（code-reviewer）
   - 检查代码风格
   - 检查命名规范
   - 检查错误处理

2. 🔒 安全审查（security-reviewer）
   - 检查 SQL 注入
   - 检查 XSS 漏洞
   - 检查认证授权

3. ⚡ 性能审查（performance）
   - 检查数据库查询
   - 检查缓存策略
   - 检查算法复杂度

等待所有代理完成...
汇总所有审查结果...
```

#### 坏的做法：不必要的顺序执行

```markdown
# 不必要的串行执行

用户："审查项目的代码、安全和性能"

AI 响应（慢）：
先进行代码审查...（等待 5 分钟）
代码审查完成

再进行安全审查...（等待 5 分钟）
安全审查完成

最后进行性能审查...（等待 5 分钟）
性能审查完成

总计：15 分钟

# 如果并行执行
总计：5 分钟（所有审查同时进行）
```

### 并行执行规则

```markdown
✅ 可以并行：
- 独立的文件分析
- 不同类型的审查
- 不依赖的任务

❌ 不能并行：
- 有依赖关系的任务
- 修改同一文件
- 需要前一步结果的任务

⚠️ 谨慎并行：
- 资源密集型任务
- 需要大量上下文的任务
```

---

## 多视角分析 (Multi-Perspective Analysis)

### 什么是多视角分析？

就像问题需要从多个角度思考：
- **事实审查者**：事实是否正确？
- **高级工程师**：实现是否合理？
- **安全专家**：是否有安全风险？
- **一致性审查者**：是否符合规范？
- **冗余检查者**：是否有重复代码？

### 使用分角色子代理

```markdown
场景：审查"用户认证系统"的设计

## 分角色分析

### 1. 事实审查者（Factual Reviewer）
关注点：
- 数据模型是否正确？
- API 端点是否完整？
- 依赖关系是否准确？

审查结果：
✅ User 模型包含必需字段
✅ API 端点覆盖所有功能
⚠️ 缺少 token 刷新机制

### 2. 高级工程师（Senior Engineer）
关注点：
- 代码结构是否清晰？
- 是否易于维护？
- 是否可扩展？

审查结果：
✅ 模块化设计清晰
✅ 职责分离良好
⚠️ 缺少日志记录

### 3. 安全专家（Security Expert）
关注点：
- 密码是否加密？
- Token 是否安全？
- 是否有注入风险？

审查结果：
✅ 使用 bcrypt 加密
✅ JWT 实现正确
🚨 缺少速率限制（CRITICAL）

### 4. 一致性审查者（Consistency Reviewer）
关注点：
- 是否符合项目规范？
- 命名是否一致？
- 风格是否统一？

审查结果：
✅ 符合 TypeScript 规范
✅ 命名遵循约定
⚠️ 错误处理不统一

### 5. 冗余检查者（Redundancy Checker）
关注点：
- 是否有重复代码？
- 是否有未使用的代码？
- 是否可以简化？

审查结果：
⚠️ 密码验证逻辑重复
⚠️ 存在未使用的工具函数

## 综合结论

必须修复：
- 添加速率限制
- 实现日志记录

建议改进：
- 统一错误处理
- 重构重复代码
- 清理未使用代码
- 添加 token 刷新
```

---

## 代理协作模式

### 模式 1：顺序协作

```
Planner（规划）
    ↓
Architect（设计）
    ↓
TDD-Guide（实现）
    ↓
Code-Reviewer（审查）
    ↓
Security-Reviewer（安全检查）
```

**使用场景**：新功能开发

### 模式 2：并行协作

```
                    → Code-Reviewer（代码质量）
Planner（规划） → ┥
                    → Security-Reviewer（安全）
                    → Performance-Reviewer（性能）
```

**使用场景**：代码审查

### 模式 3：迭代协作

```
设计 → 实现 → 审查 → 反馈 → 重新设计 ...
  ↑                            ↓
  └────────────────────────────┘
```

**使用场景**：复杂问题解决

---

## 代理调用示例

### 示例 1：实现新功能

```bash
# 用户请求
"实现用户评论功能"

# AI 自动调用代理

# 1. 规划
/planner "规划用户评论功能的实现"

# 2. 设计
/architect "设计评论系统的数据模型和 API"

# 3. 实现（TDD）
/tdd-guide "使用 TDD 实现评论功能"

# 4. 代码审查
/code-reviewer "审查评论功能的代码"

# 5. 安全审查
/security-reviewer "检查评论功能的安全性"

# 6. 完成
所有代理完成，功能实现完毕
```

### 示例 2：修复 Bug

```bash
# 用户请求
"登录时出现错误"

# AI 自动调用代理

# 1. 分析问题
"分析登录错误的原因"

# 2. 设计修复方案
/architect "设计修复方案"

# 3. 实现修复（TDD）
/tdd-guide "使用 TDD 修复登录 bug"

# 4. 验证修复
"验证修复是否有效"

# 5. 完成
Bug 修复完毕
```

### 示例 3：性能优化

```bash
# 用户请求
"优化页面加载速度"

# AI 自动调用代理

# 1. 性能分析
"分析性能瓶颈"

# 2. 并行执行多个代理
并行启动：
- Code-Reviewer（检查代码问题）
- Architect（评估架构）
- Performance-Expert（性能分析）

# 3. 汇总结果
"汇总所有分析结果"

# 4. 实现优化
/tdd-guide "实现性能优化"

# 5. 验证效果
"验证优化效果"

# 6. 完成
性能优化完成
```

---

## 常见问题 (FAQ)

### Q1: 什么时候应该手动调用代理？

**答**：
- 当你明确需要特定代理时
- 当自动调用未触发但你需要时
- 当你想控制执行顺序时

### Q2: 可以同时调用多个代理吗？

**答**：
- **可以**，如果任务相互独立
- **不可以**，如果任务有依赖关系
- **谨慎**，如果任务消耗大量资源

### Q3: 代理之间如何共享信息？

**答**：
- 通过上下文窗口
- 通过文件系统
- 通过会话状态

### Q4: 代理执行失败怎么办？

**答**：
```markdown
1. 分析失败原因
2. 尝试简化任务
3. 提供更多上下文
4. 手动执行替代方案
```

### Q5: 如何知道哪个代理最适合当前任务？

**答**：
```markdown
参考决策表：
- 规划 → planner
- 设计 → architect
- 测试 → tdd-guide
- 审查 → code-reviewer
- 安全 → security-reviewer
- 构建错误 → build-error-resolver
```

---

## 总结

### 代理选择速查表

| 任务 | 使用代理 | 记忆口诀 |
|------|----------|----------|
| 规划 | planner | 先规划后执行 |
| 设计 | architect | 设计先行 |
| 开发 | tdd-guide | 测试驱动 |
| 审查 | code-reviewer | 质量把关 |
| 安全 | security-reviewer | 安全第一 |
| 修复 | build-error-resolver | 快速排错 |

### 协作原则

```markdown
1. 自动调用：无需用户提示
2. 并行执行：独立任务同时进行
3. 多视角：从多个角度分析
4. 持续反馈：代理之间互相改进
```

### 最佳实践

```markdown
✅ DO（应该做）：
- 复杂任务先用 planner
- 代码完成后立即审查
- 独立任务并行执行
- 关键功能多视角分析

❌ DON'T（不应该做）：
- 跳过规划直接开发
- 忘记代码审查
- 不必要的顺序执行
- 忽视安全检查
```

善用代理系统，让 AI 助手更强大、更专业！
