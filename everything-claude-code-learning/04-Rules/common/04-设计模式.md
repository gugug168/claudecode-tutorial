# 设计模式 (Design Patterns)

> **规则用途**：定义通用设计模式和项目骨架使用规范
>
> **适用场景**：实现新功能、架构设计时参考
>
> **核心能力**：骨架项目、仓库模式、API 响应格式
>
> **适用范围**：通用规则

---

## 骨架项目 (Skeleton Projects)

### 什么是骨架项目？

骨架项目就像装修房子的样板间：
- 已经设计好结构
- 经过实践验证
- 可以直接使用或稍作修改

### 为什么使用骨架项目？

| 不使用骨架 | 使用骨架 |
|-----------|---------|
| 从零搭建结构 | 直接开始开发 |
| 可能走弯路 | 避免常见错误 |
| 架构不成熟 | 使用最佳实践 |
| 耗时长 | 快速启动 |

### 骨架项目使用流程

```
┌─────────────────────────────────────────────────┐
│  1. 搜索骨架项目                                  │
│     - GitHub 搜索                                │
│     - 官方模板                                   │
│     - 社区推荐                                   │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  2. 并行评估（使用多个代理）                      │
│     ├─ 安全评估代理                              │
│     ├─ 可扩展性分析代理                          │
│     ├─ 相关性评分代理                            │
│     └─ 实现规划代理                              │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  3. 选择最佳匹配                                  │
│     - 活跃维护                                   │
│     - 文档完善                                   │
│     - 社区支持                                   │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  4. 克隆并定制                                    │
│     - 克隆项目                                   │
│     - 修改配置                                   │
│     - 删除不需要的部分                           │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  5. 在验证的结构内迭代开发                        │
└─────────────────────────────────────────────────┘
```

### 骨架项目评估标准

#### 1. 安全评估

```markdown
检查项：
- [ ] 依赖包定期更新
- [ ] 有安全漏洞扫描
- [ ] 使用 HTTPS
- [ ] 环境变量配置安全
- [ ] 认证授权机制完善

工具：
- npm audit (npm)
- yarn audit (yarn)
- Snyk (第三方工具)
```

#### 2. 可扩展性分析

```markdown
检查项：
- [ ] 模块化结构清晰
- [ ] 插件系统支持
- [ ] 配置与代码分离
- [ ] 数据库抽象层
- [ ] API 版本控制

示例：
好的骨架：
src/
  ├── plugins/         # 插件目录
  ├── config/          # 配置文件
  ├── database/        # 数据库抽象
  └── api/             # API 层
      ├── v1/          # 版本 1
      └── v2/          # 版本 2
```

#### 3. 相关性评分

```markdown
评分标准：
1. 技术栈匹配度（30%）
   - 是否使用你熟悉的技术
   - 是否符合项目需求

2. 文档质量（25%）
   - README 清晰详细
   - 有代码示例
   - 有架构说明

3. 社区活跃度（25%）
   - 最近更新时间
   - Issues 响应速度
   - Star/Fork 数量

4. 学习曲线（20%）
   - 代码是否易读
   - 是否有教程
   - 社区支持如何
```

#### 4. 实现规划

```markdown
基于骨架的实现计划：
1. 第 1 周：熟悉骨架结构
2. 第 2 周：实现核心功能
3. 第 3 周：定制和优化
4. 第 4 周：测试和部署
```

### 推荐的骨架项目

#### Web 应用

| 项目 | 技术栈 | 用途 |
|------|--------|------|
| [create-react-app](https://github.com/facebook/create-react-app) | React | 单页应用 |
| [Next.js Examples](https://github.com/vercel/next.js/tree/canary/examples) | Next.js | React SSR |
| [Vite Templates](https://github.com/vitejs/vite/tree/main/packages/create-vite) | Vite | 现代前端 |
| [vue-h5-template](https://github.com/sunnie1992/vue-h5-template) | Vue | H5 应用 |

#### 后端 API

| 项目 | 技术栈 | 用途 |
|------|--------|------|
| [node-express-mongoose](https://github.com/kunalkapadia/express-mongoose-es6-rest-api) | Node.js | REST API |
| [fastify-typescript](https://github.com/fastify/fastify-typescript-plugin) | Fastify | 高性能 API |
| [nestjs-sample](https://github.com/nestjs/typescript-starter) | NestJS | 企业级 API |

#### 全栈应用

| 项目 | 技术栈 | 用途 |
|------|--------|------|
| [t3-stack](https://github.com/t3-oss/create-t3-app) | Next.js + tRPC | 全栈应用 |
| [realworld](https://github.com/gothinkrealworld) | 多种 | 真实世界示例 |

---

## 设计模式详解

### 仓库模式 (Repository Pattern)

#### 什么是仓库模式？

仓库模式就像图书馆的管理员：
- 你告诉管理员要什么书
- 管理员去书架找书
- 你不需要知道书具体在哪个书架

在代码中：
- 业务逻辑 → 仓库接口 → 数据存储
- 业务逻辑不关心数据怎么存储

#### 为什么使用仓库模式？

```
┌──────────────────────────────────────────────┐
│  不使用仓库模式（紧耦合）                      │
├──────────────────────────────────────────────┤
│                                              │
│  业务逻辑 ──直接调用──▶ 数据库操作            │
│                        │                     │
│              业务逻辑需要知道：               │
│              - 数据库连接细节                 │
│              - SQL 查询语法                   │
│              - 数据库结构                     │
│                        │                     │
│              问题：                           │
│              - 难以测试（需要真实数据库）     │
│              - 难以切换数据库                 │
│              - 业务逻辑和数据逻辑混在一起      │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│  使用仓库模式（松耦合）                        │
├──────────────────────────────────────────────┤
│                                              │
│  业务逻辑 ──调用──▶ 仓库接口 ──实现──▶ 数据库 │
│                        │                     │
│              业务逻辑只知道：                 │
│              - 接口方法（findAll, findById）  │
│              - 返回数据格式                   │
│                        │                     │
│              好处：                           │
│              - 易于测试（可以 mock 仓库）     │
│              - 易于切换存储（换实现即可）      │
│              - 职责分离                       │
└──────────────────────────────────────────────┘
```

#### 仓库模式实现

```typescript
// 1. 定义接口（契约）
interface IUserRepository {
  findAll(): Promise<User[]>;
  findById(id: string): Promise<User | null>;
  create(data: CreateUserDto): Promise<User>;
  update(id: string, data: UpdateUserDto): Promise<User>;
  delete(id: string): Promise<void>;
}

// 2. 实现接口（数据库）
class UserRepository implements IUserRepository {
  constructor(private db: Database) {}

  async findAll(): Promise<User[]> {
    const records = await this.db.query('SELECT * FROM users');
    return records.map(this.toEntity);
  }

  async findById(id: string): Promise<User | null> {
    const record = await this.db.query(
      'SELECT * FROM users WHERE id = ?',
      [id]
    );
    return record ? this.toEntity(record) : null;
  }

  async create(data: CreateUserDto): Promise<User> {
    const record = await this.db.query(
      'INSERT INTO users (name, email) VALUES (?, ?)',
      [data.name, data.email]
    );
    return this.toEntity(record);
  }

  update(id: string, data: UpdateUserDto): Promise<User> {
    // 实现更新逻辑
  }

  delete(id: string): Promise<void> {
    // 实现删除逻辑
  }

  private toEntity(record: any): User {
    return new User(record.id, record.name, record.email);
  }
}

// 3. 使用仓库（业务逻辑）
class UserService {
  constructor(private userRepo: IUserRepository) {}

  async getUser(id: string): Promise<User | null> {
    // 业务逻辑不需要知道数据如何存储
    return await this.userRepo.findById(id);
  }

  async createAdmin(data: CreateUserDto): Promise<User> {
    const user = await this.userRepo.create(data);
    // 其他业务逻辑...
    return user;
  }
}
```

#### 测试中的优势

```typescript
// 测试时使用 mock 仓库
class MockUserRepository implements IUserRepository {
  private users: User[] = [];

  async findAll(): Promise<User[]> {
    return this.users;
  }

  async findById(id: string): Promise<User | null> {
    return this.users.find(u => u.id === id) || null;
  }

  async create(data: CreateUserDto): Promise<User> {
    const user = new User('1', data.name, data.email);
    this.users.push(user);
    return user;
  }

  // ... 其他方法
}

// 测试业务逻辑（不需要真实数据库）
describe('UserService', () => {
  it('should create admin user', async () => {
    const mockRepo = new MockUserRepository();
    const service = new UserService(mockRepo);

    const user = await service.createAdmin({
      name: 'Admin',
      email: 'admin@example.com'
    });

    expect(user.name).toBe('Admin');
  });
});
```

#### 仓库模式适用场景

| 适用 | 不适用 |
|------|--------|
| 需要支持多种数据存储 | 简单的 CRUD 应用 |
| 复杂的业务逻辑 | 数据访问逻辑简单 |
| 需要单元测试 | 原型开发 |
| 团队协作项目 | 个人小项目 |

---

### API 响应格式 (API Response Format)

#### 什么是 API 响应格式？

API 响应格式就像快递包裹的标准化包装：
- 统一的包装格式
- 清晰的标签（成功/失败）
- 包含内容（数据/错误）

#### 标准响应结构

```typescript
// 成功响应
{
  "success": true,           // 成功标识
  "data": {                  // 数据负载
    "id": "123",
    "name": "张三",
    "email": "zhangsan@example.com"
  },
  "message": "操作成功",     // 可选：成功消息
  "timestamp": "2024-01-15T10:30:00Z"  // 可选：时间戳
}

// 错误响应
{
  "success": false,          // 失败标识
  "error": {                 // 错误信息
    "code": "USER_NOT_FOUND",
    "message": "用户不存在",
    "details": {
      "userId": "123"
    }
  },
  "timestamp": "2024-01-15T10:30:00Z"
}

// 分页响应
{
  "success": true,
  "data": [                  // 数据数组
    { "id": "1", "name": "张三" },
    { "id": "2", "name": "李四" }
  ],
  "pagination": {            // 分页信息
    "total": 100,            // 总数
    "page": 1,               // 当前页
    "limit": 10,             // 每页数量
    "pages": 10              // 总页数
  }
}
```

#### 实现示例

```typescript
// 1. 定义响应类型
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  timestamp?: string;
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}

// 2. 创建响应辅助函数
class ResponseHelper {
  static success<T>(data: T, message?: string): ApiResponse<T> {
    return {
      success: true,
      data,
      message,
      timestamp: new Date().toISOString()
    };
  }

  static error(
    code: string,
    message: string,
    details?: any
  ): ApiResponse {
    return {
      success: false,
      error: { code, message, details },
      timestamp: new Date().toISOString()
    };
  }

  static paginated<T>(
    data: T[],
    pagination: {
      total: number;
      page: number;
      limit: number;
    }
  ): PaginatedResponse<T> {
    return {
      success: true,
      data,
      pagination: {
        ...pagination,
        pages: Math.ceil(pagination.total / pagination.limit)
      },
      timestamp: new Date().toISOString()
    };
  }
}

// 3. 在路由中使用
import { ResponseHelper } from './response';

// Express 示例
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await userService.findById(req.params.id);

    if (!user) {
      return res.status(404).json(
        ResponseHelper.error(
          'USER_NOT_FOUND',
          '用户不存在',
          { userId: req.params.id }
        )
      );
    }

    res.json(ResponseHelper.success(user));
  } catch (error) {
    res.status(500).json(
      ResponseHelper.error(
        'INTERNAL_ERROR',
        '服务器错误'
      )
    );
  }
});

app.get('/api/users', async (req, res) => {
  const { page = 1, limit = 10 } = req.query;

  const [users, total] = await userService.findAll({
    page: Number(page),
    limit: Number(limit)
  });

  res.json(
    ResponseHelper.paginated(users, {
      total,
      page: Number(page),
      limit: Number(limit)
    })
  );
});
```

#### HTTP 状态码使用

| 状态码 | 含义 | 使用场景 |
|--------|------|----------|
| **200** | 成功 | 成功获取/更新/删除资源 |
| **201** | 已创建 | 成功创建新资源 |
| **204** | 无内容 | 成功删除（无返回内容） |
| **400** | 请求错误 | 用户输入验证失败 |
| **401** | 未授权 | 未登录或 token 失效 |
| **403** | 禁止访问 | 已登录但无权限 |
| **404** | 未找到 | 资源不存在 |
| **422** | 无法处理 | 业务逻辑验证失败 |
| **500** | 服务器错误 | 服务器内部错误 |

#### 错误代码规范

```typescript
// 定义错误代码常量
enum ErrorCodes {
  // 通用错误 (1xxx)
  VALIDATION_ERROR = '1000',
  UNAUTHORIZED = '1001',
  FORBIDDEN = '1002',
  NOT_FOUND = '1003',
  INTERNAL_ERROR = '1004',

  // 用户错误 (2xxx)
  USER_NOT_FOUND = '2001',
  USER_EMAIL_EXISTS = '2002',
  USER_INVALID_PASSWORD = '2003',

  // 资源错误 (3xxx)
  RESOURCE_NOT_FOUND = '3001',
  RESOURCE_ALREADY_EXISTS = '3002',

  // 业务错误 (4xxx)
  INSUFFICIENT_BALANCE = '4001',
  ORDER_CANNOT_CANCEL = '4002',
}

// 使用示例
throw new AppError(
  ErrorCodes.USER_EMAIL_EXISTS,
  '该邮箱已被注册',
  { email: userInput.email }
);
```

---

## 其他常用设计模式

### 1. 工厂模式 (Factory Pattern)

```typescript
// 创建对象而不指定具体类
interface Notifier {
  send(message: string): void;
}

class EmailNotifier implements Notifier {
  send(message: string) {
    console.log(`发送邮件: ${message}`);
  }
}

class SMSNotifier implements Notifier {
  send(message: string) {
    console.log(`发送短信: ${message}`);
  }
}

// 工厂函数
class NotifierFactory {
  static create(type: 'email' | 'sms'): Notifier {
    switch (type) {
      case 'email':
        return new EmailNotifier();
      case 'sms':
        return new SMSNotifier();
      default:
        throw new Error('不支持的类型');
    }
  }
}

// 使用
const notifier = NotifierFactory.create('email');
notifier.send('你好！');
```

### 2. 策略模式 (Strategy Pattern)

```typescript
// 定义算法族，分别封装
interface PaymentStrategy {
  pay(amount: number): void;
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`信用卡支付 ${amount} 元`);
  }
}

class WeChatPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`微信支付 ${amount} 元`);
  }
}

class AlipayPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`支付宝支付 ${amount} 元`);
  }
}

// 使用策略
class ShoppingCart {
  private paymentStrategy: PaymentStrategy;

  setPaymentMethod(strategy: PaymentStrategy) {
    this.paymentStrategy = strategy;
  }

  checkout(amount: number) {
    this.paymentStrategy.pay(amount);
  }
}

// 使用
const cart = new ShoppingCart();
cart.setPaymentMethod(new WeChatPayment());
cart.checkout(100); // 微信支付 100 元
```

### 3. 单例模式 (Singleton Pattern)

```typescript
// 确保只有一个实例
class Database {
  private static instance: Database;
  private connection: any;

  private constructor() {
    // 私有构造函数
    this.connection = this.connect();
  }

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  private connect() {
    console.log('创建数据库连接');
    return {}; // 模拟连接
  }

  query(sql: string) {
    console.log(`执行查询: ${sql}`);
  }
}

// 使用
const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2); // true - 同一个实例
```

---

## 常见问题 (FAQ)

### Q1: 设计模式会让代码变复杂吗？

**答**：
- **初期**：可能会增加一些代码量
- **长期**：减少重复，提高可维护性
- **原则**：不要过度设计，只在需要时使用

### Q2: 如何知道什么时候该用设计模式？

**答**：
- **重复代码出现 3 次** → 考虑提取模式
- **业务逻辑和数据逻辑混在一起** → 仓库模式
- **多个条件分支做类似的事情** → 策略模式
- **需要全局唯一实例** → 单例模式

### Q3: 所有项目都需要骨架吗？

**答**：
- **学习项目**：可以从零开始，理解原理
- **生产项目**：推荐使用骨架，节省时间
- **团队项目**：应该使用骨架，保持一致性

### Q4: 仓库模式会让性能变差吗？

**答**：
- **额外抽象层**：可能有轻微性能影响
- **可优化**：可以通过缓存、批量操作优化
- **权衡**：可维护性通常比微小性能更重要

---

## 总结

### 设计模式选择指南

| 场景 | 推荐模式 | 理由 |
|------|----------|------|
| **数据访问复杂** | 仓库模式 | 解耦业务和数据 |
| **多种支付方式** | 策略模式 | 算法可替换 |
| **创建对象复杂** | 工厂模式 | 封装创建逻辑 |
| **全局配置** | 单例模式 | 唯一实例 |
| **API 统一** | 响应封装 | 一致性 |

### 使用原则

```
1. 简单优于复杂
   - 不要过度设计
   - 先解决问题，再考虑模式

2. 模式服务于需求
   - 不要为了用模式而用模式
   - 理解模式的适用场景

3. 保持代码可读
   - 清晰的命名
   - 适当的注释
   - 示例和文档
```

### 学习建议

```markdown
初学者路径：
1. 理解问题：识别代码中的坏味道
2. 学习模式：了解常见模式的用途
3. 实践应用：在实际项目中尝试
4. 重构优化：不断改进设计

进阶路径：
1. 深入理解：掌握多个模式的组合
2. 自适应变通：根据情况调整模式
3. 创造模式：总结自己的最佳实践
```

记住：设计模式是工具，不是目的！
