# 性能优化 (Performance Optimization)

> **规则用途**：定义性能优化和模型选择策略
>
> **适用场景**：选择模型、管理上下文窗口、排查构建问题时参考
>
> **核心能力**：模型选择、上下文窗口管理、扩展思考、构建故障排除
>
> **适用范围**：通用规则

---

## 模型选择策略 (Model Selection Strategy)

### 为什么需要选择合适的模型？

想象出门选交通工具：
- **步行**：短距离，免费但慢
- **自行车**：中距离，平衡速度和成本
- **汽车**：长距离，快速但昂贵
- **飞机**：超长距离，最快但最贵

AI 模型也是一样：
- **Haiku**：简单任务，快速便宜
- **Sonnet**：标准任务，性能和成本平衡
- **Opus**：复杂任务，最强能力

### 三种模型对比

| 特性 | Haiku 4.5 | Sonnet 4.5 | Opus 4.5 |
|------|-----------|------------|----------|
| **能力** | 90% Sonnet | 基准（100%） | 最强 |
| **速度** | 最快 | 快 | 较慢 |
| **成本** | 1x | 3x | 15x |
| **上下文** | 200K tokens | 200K tokens | 200K tokens |
| **适用场景** | 轻量级任务 | 标准开发 | 复杂推理 |

### Haiku 4.5 使用场景

#### 适合 Haiku 的任务

```markdown
1. 轻量级代理（频繁调用）
   - 代码格式检查
   - 简单文件查找
   - 快速信息提取

2. 结对编程
   - 代码补全
   - 语法检查
   - 命名建议

3. 工作代理
   - 在多代理系统中执行具体任务
   - 不需要复杂推理的操作
```

#### Haiku 示例

```typescript
// ✅ 适合 Haiku：简单文件搜索
"找出所有的 .test.js 文件"

// ✅ 适合 Haiku：代码格式化
"格式化这个函数，使其符合 Prettier 规范"

// ✅ 适合 Haiku：重命名变量
"将所有的 'userName' 重命名为 'username'"

// ❌ 不适合 Haiku：复杂架构设计
"设计一个微服务架构的认证系统"（用 Sonnet 或 Opus）
```

#### 成本对比示例

```
任务：格式化 100 个文件

使用 Sonnet：
- 100 次调用 × $0.003/次 = $0.30

使用 Haiku：
- 100 次调用 × $0.001/次 = $0.10

节省：66% 的成本
```

### Sonnet 4.5 使用场景

#### 适合 Sonnet 的任务

```markdown
1. 主要开发工作
   - 编写新功能
   - 修复 bug
   - 代码重构

2. 协调多代理工作流
   - 任务分配
   - 结果整合
   - 进度跟踪

3. 复杂编码任务
   - 算法实现
   - 数据处理
   - API 集成
```

#### Sonnet 示例

```typescript
// ✅ 适合 Sonnet：实现功能
"实现一个用户认证系统，包括登录、注册和密码重置"

// ✅ 适合 Sonnet：修复 bug
"修复这个异步函数中的竞态条件问题"

// ✅ 适合 Sonnet：重构代码
"重构这个类，使其符合单一职责原则"

// ✅ 适合 Sonnet：协调任务
"分解这个任务并分配给不同的代理处理"
```

### Opus 4.5 使用场景

#### 适合 Opus 的任务

```markdown
1. 复杂架构决策
   - 系统设计
   - 技术选型
   - 架构评估

2. 最大推理需求
   - 复杂问题分析
   - 多方案对比
   - 深度代码审查

3. 研究和分析任务
   - 技术调研
   - 性能分析
   - 安全审计
```

#### Opus 示例

```typescript
// ✅ 适合 Opus：架构设计
"设计一个支持千万级用户的微服务架构，
考虑高可用、可扩展性和容错性"

// ✅ 适合 Opus：深度分析
"分析这个代码库的性能瓶颈，并提供优化方案，
考虑数据库、网络和算法三个层面"

// ✅ 适合 Opus：技术选型
"对比 React、Vue 和 Svelte，为我们的项目选择最合适的框架，
考虑团队技能、项目规模和长期维护"

// ❌ 不适合 Opus：简单任务
"这个函数怎么调用？"（用 Haiku 或 Sonnet）
```

### 模型选择决策树

```
开始
  │
  ├─► 任务复杂度？
  │   ├─ 简单（查询、格式化）→ Haiku
  │   ├─ 标准（开发、重构）→ Sonnet
  │   └─ 复杂（架构、研究）→ Opus
  │
  ├─► 调用频率？
  │   ├─ 高频（100+ 次）→ Haiku
  │   ├─ 中频（10-100 次）→ Sonnet
  │   └─ 低频（< 10 次）→ Opus
  │
  ├─► 成本敏感？
  │   ├─ 是 → 优先 Haiku，必要时 Sonnet
  │   └─ 否 → 根据任务复杂度选择
  │
  └─► 时间限制？
      ├─ 紧急 → 优先速度（Haiku 或 Sonnet）
      └─ 充足 → 优先质量（Sonnet 或 Opus）
```

### 模型选择最佳实践

| 场景 | 推荐模型 | 理由 |
|------|----------|------|
| **代码补全** | Haiku | 快速响应，成本可控 |
| **功能开发** | Sonnet | 平衡能力和速度 |
| **代码审查** | Sonnet/Opus | 需要深度理解 |
| **架构设计** | Opus | 需要全局视角 |
| **调试** | Sonnet | 需要推理但不过度 |
| **文档编写** | Haiku/Sonnet | 简单任务用 Haiku |
| **学习新概念** | Sonnet | 需要详细解释 |
| **紧急修复** | Haiku/Sonnet | 速度优先 |

---

## 上下文窗口管理 (Context Window Management)

### 什么是上下文窗口？

上下文窗口就像工作台的桌面大小：
- **小桌面**：只能放几份文件，需要频繁整理
- **大桌面**：可以放很多文件，但要避免杂乱

AI 的上下文窗口：
- Haiku/Sonnet/Opus：200K tokens
- 约等于 15 万个汉字
- 或 20-30 页代码

### 上下文窗口使用策略

#### 避免在窗口最后 20% 进行复杂操作

```
┌─────────────────────────────────────────────────┐
│  上下文窗口（100%）                               │
├─────────────────────────────────────────────────┤
│  前 80% - 安全区 ✅                              │
│  ────────────────────────                        │
│  适合：                                          │
│  ✓ 大规模重构                                     │
│  ✓ 跨文件功能实现                                 │
│  ✓ 复杂交互调试                                   │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│  后 20% - 风险区 ⚠️                              │
│  ─────────────                                    │
│  不适合：                                        │
│  ✗ 大规模重构（可能信息不足）                      │
│  ✗ 跨文件功能实现（可能遗漏依赖）                  │
│  ✗ 复杂交互调试（可能上下文不全）                  │
└─────────────────────────────────────────────────┘
```

#### 低上下文敏感度的任务

在上下文窗口后期（接近 20% 限制），这些任务仍然安全：

```markdown
✅ 安全操作（低上下文依赖）：
1. 单文件编辑
   - 修改一个函数
   - 更新配置文件
   - 添加注释

2. 独立工具创建
   - 创建新的工具函数
   - 独立的小脚本
   - 不依赖复杂上下文

3. 文档更新
   - 更新 README
   - 添加使用说明
   - 补充注释

4. 简单 bug 修复
   - 修复明显的错误
   - 不涉及多个文件
   - 不需要深度理解
```

### 上下文管理技巧

#### 1. 定期清理

```markdown
# 在长对话中，定期总结并清理上下文

你：
"让我们总结一下目前的状态..."

AI：
"已完成：
1. ✅ 用户认证系统
2. ✅ 数据库设计
3. ✅ API 端点

接下来：
4. ⏳ 前端界面
5. ⏳ 测试
6. ⏳ 文档"

效果：
- 清理了详细的代码讨论
- 保留了关键进展
- 为新任务腾出空间
```

#### 2. 使用文件系统

```markdown
# 不在上下文中保存大量信息

❌ 错误做法：
在对话中列出所有配置项

✅ 正确做法：
创建配置文件
AI 可以随时读取

好处：
- 上下文窗口保持清爽
- 配置持久化存储
- 可以版本控制
```

#### 3. 分阶段处理

```markdown
# 复杂任务分阶段完成

阶段 1：规划
- 生成完整计划
- 保存到文件
- 清理上下文

阶段 2：执行
- 读取计划文件
- 逐步执行
- 定期清理

阶段 3：验证
- 读取计划文件
- 验证完成情况
- 生成报告
```

---

## 扩展思考 + 计划模式

### 什么是扩展思考？

扩展思考就像"草稿纸"：
- AI 在给出答案前先思考
- 类似于你的内心独白
- 最多保留 31,999 个 tokens 的思考内容

### 扩展思考的控制方式

| 方法 | 操作 | 说明 |
|------|------|------|
| **快捷键** | Option+T (macOS)<br>Alt+T (Windows/Linux) | 切换开关 |
| **配置文件** | `~/.claude/settings.json`<br>`alwaysThinkingEnabled: true` | 永久启用 |
| **环境变量** | `export MAX_THINKING_TOKENS=10000` | 限制 token 数量 |
| **详细模式** | Ctrl+O | 显示思考内容 |

### 扩展思考的作用

```
┌─────────────────────────────────────────────────┐
│  没有扩展思考                                     │
├─────────────────────────────────────────────────┤
│  用户：实现一个排序算法                          │
│                                                  │
│  AI：直接给出代码                                │
│  （可能没有充分考虑边界情况）                      │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  有扩展思考                                       │
├─────────────────────────────────────────────────┤
│  用户：实现一个排序算法                          │
│                                                  │
│  AI（思考中）：                                   │
│  - 需要考虑什么排序算法？                         │
│  - 快排？归并？堆排序？                           │
│  - 时间复杂度要求？                               │
│  - 空间复杂度要求？                               │
│  - 数据规模？                                     │
│  - 是否需要稳定排序？                             │
│  - 边界情况：空数组、单元素、已排序               │
│                                                  │
│  AI（基于思考给出答案）：                         │
│  "我推荐使用快速排序...                           │
│   考虑到以下几点...                               │
│   这里是实现..."                                 │
└─────────────────────────────────────────────────┘
```

### 复杂任务的深度推理策略

对于需要深度思考的复杂任务：

#### 1. 确保扩展思考已启用

```json
// ~/.claude/settings.json
{
  "alwaysThinkingEnabled": true,  // 永久启用
  "maxThinkingTokens": 31999      // 最大思考量
}
```

#### 2. 启用计划模式

```markdown
计划模式让 AI 先规划再执行：

用户：实现一个用户认证系统

AI（计划模式）：
第一阶段：需求分析
- 分析认证需求
- 识别安全考虑
- 确定技术栈

第二阶段：架构设计
- 设计数据模型
- 设计 API 接口
- 规划安全措施

第三阶段：实现
- 实现密码加密
- 实现 JWT 生成
- 实现认证中间件

第四阶段：测试
- 单元测试
- 集成测试
- 安全测试
```

#### 3. 使用多轮批判

```markdown
批判循环让 AI 自我审查和改进：

第一轮：生成初步方案
AI：我建议使用 JWT 进行认证...

第二轮：自我批判
AI：等一下，让我重新考虑：
- JWT 的安全性够吗？
- 是否需要 refresh token？
- 如何处理 token 泄露？

第三轮：改进方案
AI：基于上述考虑，我改进了方案：
- 添加 refresh token 机制
- 使用 httpOnly cookie
- 实现token 黑名单...
```

#### 4. 使用分角色子代理

```markdown
多视角分析复杂问题：

架构师视角：
- 系统可扩展性如何？
- 模块间耦合度如何？
- 是否符合 SOLID 原则？

安全专家视角：
- 有哪些安全风险？
- 如何防范常见攻击？
- 密钥管理是否安全？

性能专家视角：
- 数据库查询是否优化？
- 是否有性能瓶颈？
- 缓存策略是否合理？

用户视角：
- API 是否易用？
- 错误消息是否友好？
- 文档是否清晰？
```

---

## 构建故障排除 (Build Troubleshooting)

### 常见构建错误

| 错误类型 | 典型原因 | 快速诊断 |
|----------|----------|----------|
| **语法错误** | 代码语法问题 | 查看错误行号 |
| **类型错误** | TypeScript 类型不匹配 | 查看类型定义 |
| **依赖错误** | 包未安装或版本冲突 | 检查 package.json |
| **配置错误** | 构建配置问题 | 查看配置文件 |
| **权限错误** | 文件权限问题 | 检查文件权限 |

### 故障排除流程

```
┌─────────────────────────────────────────────────┐
│  构建失败                                         │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  1. 使用 build-error-resolver 代理               │
│     /build-fixer "分析构建错误"                  │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  2. 分析错误消息                                  │
│     - 识别错误类型                               │
│     - 定位错误位置                               │
│     - 理解错误原因                               │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  3. 逐步修复                                      │
│     - 修复一个错误                               │
│     - 重新构建                                   │
│     - 继续下一个错误                             │
└──────────────┬──────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────┐
│  4. 每次修复后验证                                │
│     - 构建是否通过                               │
│     - 测试是否通过                               │
│     - 没有引入新问题                             │
└─────────────────────────────────────────────────┘
```

### 常见问题与解决

#### 问题 1：TypeScript 类型错误

```typescript
// 错误示例
const user: User = getUser();  // Type 'any' is not assignable to type 'User'

// 解决方法 1：添加类型断言
const user = getUser() as User;

// 解决方法 2：修复返回类型
function getUser(): User {
  // ...
}

// 解决方法 3：使用类型守卫
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'string';
}
```

#### 问题 2：依赖包版本冲突

```bash
# 问题：npm install 报错
npm ERR! peer dep missing: react@^18.0.0

# 解决方法 1：安装缺失的依赖
npm install react@^18.0.0

# 解决方法 2：使用 --legacy-peer-deps（临时方案）
npm install --legacy-peer-deps

# 解决方法 3：更新所有依赖
npm update

# 解决方法 4：清理并重新安装
rm -rf node_modules package-lock.json
npm install
```

#### 问题 3：构建缓存问题

```bash
# 清理构建缓存
npm run clean  # 如果有 clean 脚本

# 或手动清理
rm -rf dist build
rm -rf .cache

# 重新构建
npm run build
```

#### 问题 4：环境变量问题

```bash
# 检查环境变量
echo $NODE_ENV
echo $API_KEY

# 临时设置
export NODE_ENV=production
npm run build

# 永久设置：添加到 .env 文件
echo "NODE_ENV=production" >> .env
```

### 使用 Build-Fixer 代理

```bash
# 调用 build-fixer 代理
/build-fixer "构建失败，错误信息如下："

# 代理会：
# 1. 分析错误消息
# 2. 识别错误类型
# 3. 提供修复方案
# 4. 执行修复
# 5. 验证构建
```

---

## 性能优化最佳实践

### 1. 选择合适的模型

```
简单任务 → Haiku（快速、便宜）
标准任务 → Sonnet（平衡）
复杂任务 → Opus（最强）
```

### 2. 管理上下文窗口

```
定期清理：总结并删除旧内容
使用文件：持久化重要信息
分阶段：复杂任务分多个阶段
```

### 3. 利用扩展思考

```
复杂任务：启用扩展思考
计划模式：先规划后执行
多轮批判：自我审查和改进
```

### 4. 及时处理构建错误

```
使用代理：build-error-resolver
逐步修复：一次修复一个问题
验证每次：确保没有引入新问题
```

---

## 常见问题 (FAQ)

### Q1: 何时使用 Haiku vs Sonnet？

**答**：
- **Haiku**：高频、简单、重复性任务（如代码检查）
- **Sonnet**：标准开发任务（如实现功能）
- **成本敏感**：优先 Haiku，必要时升级到 Sonnet

### Q2: 如何知道上下文窗口快满了？

**答**：
- 观察 AI 的响应质量（开始遗忘之前的上下文）
- 查看对话轮数（通常 50-100 轮后需要清理）
- 定期总结并清理（每 20-30 轮）

### Q3: 扩展思考会增加成本吗？

**答**：
- **是的**：扩展思考消耗 tokens
- **但值得**：提高输出质量，减少返工
- **可控制**：调整 MAX_THINKING_TOKENS 限制

### Q4: 构建错误应该自己修复还是用代理？

**答**：
- **简单错误**：自己修复（更快）
- **复杂错误**：使用 build-fixer 代理
- **反复出现的错误**：使用代理并分析根本原因

### Q5: 如何平衡性能和质量？

**答**：
```markdown
性能优先（快速迭代）：
- 使用 Haiku 处理简单任务
- 减少扩展思考
- 快速原型开发

质量优先（生产代码）：
- 使用 Sonnet/Opus
- 启用扩展思考
- 充分测试和审查
```

---

## 总结

### 模型选择速查表

| 任务 | 模型 | 理由 |
|------|------|------|
| 代码补全 | Haiku | 快速响应 |
| 功能开发 | Sonnet | 平衡性能 |
| 架构设计 | Opus | 深度推理 |
| 代码审查 | Sonnet/Opus | 质量优先 |
| 简单查询 | Haiku | 成本效益 |
| 复杂调试 | Sonnet | 推理能力 |

### 上下文管理技巧

```markdown
✅ DO：
- 定期总结并清理
- 使用文件系统存储
- 分阶段处理复杂任务
- 监控上下文使用

❌ DON'T：
- 在上下文中保存大量代码
- 重复相同信息
- 忽视上下文限制
```

### 性能优化总结

```markdown
1. 模型选择：根据任务复杂度
2. 上下文管理：定期清理和总结
3. 扩展思考：复杂任务启用
4. 构建修复：使用代理加速
```

记住：性能优化是一个平衡过程，根据具体情况灵活调整！
