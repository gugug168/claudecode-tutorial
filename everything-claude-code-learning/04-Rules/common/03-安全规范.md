# 安全规范 (Security Guidelines)

> **规则用途**：定义安全检查和密钥管理规范
>
> **适用场景**：提交前检查、发现安全问题时参考
>
> **核心能力**：强制安全检查、密钥管理、安全响应协议
>
> **适用范围**：通用规则

---

## 强制安全检查清单

### 为什么安全如此重要？

想象你的房子：
- **没有安全措施** = 门窗大开，任何人都可以进出
- **有安全措施** = 锁好门窗，只有授权的人才能进入

代码也是一样：
- 安全漏洞可能导致数据泄露
- 用户信任一旦破坏很难恢复
- 修复安全问题的成本很高

### 提交前的安全检查

在**每次提交代码前**，必须检查以下项目：

| 检查项 | 说明 | 风险等级 |
|--------|------|----------|
| **无硬编码密钥** | API 密钥、密码、令牌不能写在代码中 | 🔴 严重 |
| **所有用户输入已验证** | 验证前端传入的所有数据 | 🔴 严重 |
| **SQL 注入防护** | 使用参数化查询，不要拼接 SQL | 🔴 严重 |
| **XSS 防护** | 清理用户输入的 HTML 内容 | 🔴 严重 |
| **CSRF 保护** | 表单提交需要 CSRF token | 🟠 高危 |
| **认证/授权验证** | 确认用户身份和权限 | 🟠 高危 |
| **速率限制** | 所有 API 端点都要限制请求频率 | 🟡 中危 |
| **错误消息安全** | 不泄露敏感信息 | 🟡 中危 |

---

## 常见安全漏洞详解

### 1. 硬编码密钥 (Hardcoded Secrets)

#### 什么是硬编码密钥？

直接将敏感信息写在代码中：

```javascript
// ❌ 错误示例：硬编码密钥
const API_KEY = "sk_live_1234567890abcdef";
const DB_PASSWORD = "mysecretpassword";
const JWT_SECRET = "secret_key_123";

async function fetchPayment() {
  const response = await fetch('https://api.stripe.com/v1/charges', {
    headers: {
      'Authorization': `Bearer ${API_KEY}` // 密钥暴露在代码中
    }
  });
}
```

#### 为什么危险？

- 代码上传到 GitHub = 所有人都能看到密钥
- 任何人都可以使用你的密钥
- 可能导致财务损失或数据泄露

#### 正确做法

```javascript
// ✅ 正确示例：使用环境变量
// .env 文件（不提交到 Git）
STRIPE_API_KEY=sk_live_1234567890abcdef
DB_PASSWORD=mysecretpassword
JWT_SECRET=secret_key_123

// 代码中
const API_KEY = process.env.STRIPE_API_KEY;
const DB_PASSWORD = process.env.DB_PASSWORD;
const JWT_SECRET = process.env.JWT_SECRET;

// 启动时验证必需的环境变量
if (!API_KEY) {
  throw new Error('缺少 STRIPE_API_KEY 环境变量');
}
```

#### 环境变量最佳实践

```javascript
// config.js - 集中管理环境变量
export const config = {
  // 必需的环境变量（缺少会报错）
  stripeApiKey: getEnvVar('STRIPE_API_KEY'),
  dbPassword: getEnvVar('DB_PASSWORD'),
  jwtSecret: getEnvVar('JWT_SECRET'),

  // 可选的环境变量（有默认值）
  port: parseInt(process.env.PORT || '3000'),
  nodeEnv: process.env.NODE_ENV || 'development',
};

function getEnvVar(name) {
  const value = process.env[name];
  if (!value) {
    throw new Error(`缺少必需的环境变量: ${name}`);
  }
  return value;
}

// 应用启动时立即验证
// config.js 被引入时就会检查
```

---

### 2. SQL 注入 (SQL Injection)

#### 什么是 SQL 注入？

攻击者通过恶意构造的输入来操纵数据库查询。

#### 为什么危险？

```javascript
// ❌ 错误示例：SQL 注入漏洞
async function getUserByEmail(email) {
  // 恶意输入：email = "admin' OR '1'='1"
  const query = `SELECT * FROM users WHERE email = '${email}'`;

  // 实际执行的 SQL：
  // SELECT * FROM users WHERE email = 'admin' OR '1'='1'
  // 结果：返回所有用户（包括管理员）

  return await database.query(query);
}
```

#### 正确做法：参数化查询

```javascript
// ✅ 正确示例：使用参数化查询
async function getUserByEmail(email) {
  // 使用参数，数据库会自动转义特殊字符
  const query = `SELECT * FROM users WHERE email = ?`;
  return await database.query(query, [email]);
}

// 或者使用 ORM（对象关系映射）
async function getUserByEmail(email) {
  return await User.findOne({ where: { email } });
  // ORM 会自动处理参数化
}
```

#### 对比表

| 方式 | 安全性 | 可读性 | 性能 |
|------|--------|--------|------|
| 字符串拼接 | ❌ 不安全 | 差 | 好 |
| 参数化查询 | ✅ 安全 | 好 | 好 |
| ORM | ✅ 安全 | 最好 | 略差 |

---

### 3. XSS 跨站脚本攻击 (Cross-Site Scripting)

#### 什么是 XSS？

攻击者在网页中注入恶意脚本，窃取用户数据。

#### 攻击示例

```javascript
// ❌ 错误示例：XSS 漏洞
function renderComment(userInput) {
  // 恶意输入：
  // userInput = '<script>stealCookies()</script>'

  document.body.innerHTML = `
    <div class="comment">
      ${userInput} // 脚本会被执行！
    </div>
  `;
}
```

#### 正确做法：清理用户输入

```javascript
// ✅ 正确示例：转义特殊字符
import DOMPurify from 'dompurify';

function renderComment(userInput) {
  // DOMPurify 会移除或转义危险标签
  const clean = DOMPurify.sanitize(userInput);

  document.body.innerHTML = `
    <div class="comment">
      ${clean} // 安全显示
    </div>
  `;
}

// 或者使用 textContent（更安全）
function renderComment(userInput) {
  const div = document.createElement('div');
  div.textContent = userInput; // 自动转义
  document.body.appendChild(div);
}
```

#### XSS 防护清单

- [ ] 所有用户输入都经过清理
- [ ] 使用 `textContent` 而不是 `innerHTML`
- [ ] 使用 Content Security Policy (CSP)
- [ ] 设置 HttpOnly cookie（防止 JavaScript 访问）

---

### 4. CSRF 跨站请求伪造 (Cross-Site Request Forgery)

#### 什么是 CSRF？

攻击者诱骗用户在已登录的网站上执行非预期操作。

#### 攻击场景

```
1. 用户登录银行网站（bank.com）
2. 用户访问恶意网站（evil.com）
3. evil.com 包含代码：
   <form action="https://bank.com/transfer" method="POST">
     <input name="to" value="攻击者账号">
     <input name="amount" value="10000">
   </form>
   <script>document.forms[0].submit();</script>
4. 浏览器自动发送用户的 cookies
5. 银行网站执行转账操作
```

#### 正确做法：CSRF Token

```javascript
// 服务端：生成 CSRF Token
app.get('/form', (req, res) => {
  const csrfToken = generateToken(); // 生成随机 token
  res.cookie('csrfToken', csrfToken, { httpOnly: true });
  res.render('form', { csrfToken });
});

// 表单中包含 token
<form method="POST" action="/transfer">
  <input type="hidden" name="csrfToken" value="{{csrfToken}}">
  <input name="to" placeholder="收款人">
  <input name="amount" placeholder="金额">
  <button type="submit">转账</button>
</form>

// 服务端：验证 Token
app.post('/transfer', (req, res) => {
  const { csrfToken } = req.body;
  const tokenFromCookie = req.cookies.csrfToken;

  if (csrfToken !== tokenFromCookie) {
    return res.status(403).json({ error: 'CSRF token 验证失败' });
  }

  // 处理转账
});
```

#### 额外防护措施

- [ ] SameSite cookie 属性
- [ ] 检查 Referer 头
- [ ] 重要操作需要二次确认（如输入密码）

---

### 5. 认证和授权 (Authentication & Authorization)

#### 认证 vs 授权

- **认证 (Authentication)**：确认"你是谁"
- **授权 (Authorization)**：确认"你能做什么"

#### 常见错误

```javascript
// ❌ 错误示例 1：只检查登录状态，不检查权限
app.delete('/api/users/:id', async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ error: '未登录' });
  }

  // 任何登录用户都可以删除任何人！
  await deleteUser(req.params.id);
  res.json({ success: true });
});

// ✅ 正确示例：检查权限
app.delete('/api/users/:id', async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ error: '未登录' });
  }

  // 只有管理员或用户本人可以删除
  if (req.user.role !== 'admin' && req.user.id !== req.params.id) {
    return res.status(403).json({ error: '无权限' });
  }

  await deleteUser(req.params.id);
  res.json({ success: true });
});

// ❌ 错误示例 2：前端验证（不可信）
// 前端代码
if (user.role === 'admin') {
  fetch('/api/delete-all', { method: 'DELETE' });
}

// 攻击者可以绕过前端直接调用 API！
// 用户可以打开浏览器控制台手动发送请求

// ✅ 正确示例：后端必须验证
app.delete('/api/delete-all', async (req, res) => {
  // 后端必须再次验证权限
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: '需要管理员权限' });
  }

  // 执行操作
  await deleteAllUsers();
  res.json({ success: true });
});
```

---

### 6. 速率限制 (Rate Limiting)

#### 为什么需要速率限制？

防止滥用和攻击：
- 防止暴力破解密码
- 防止 API 被滥用
- 防止 DDoS 攻击
- 保护服务器资源

#### 实现示例

```javascript
// 使用 express-rate-limit
import rateLimit from 'express-rate-limit';

// 通用限制：每分钟 100 个请求
const generalLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 分钟
  max: 100,
  message: '请求过于频繁，请稍后再试'
});

// 登录限制：每 15 分钟 5 次尝试
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 分钟
  max: 5,
  message: '登录尝试次数过多，请稍后再试'
});

// 应用限制
app.use('/api/', generalLimiter);
app.post('/api/login', loginLimiter, loginHandler);
```

#### 不同端点的限制建议

| 端点类型 | 限制 | 理由 |
|----------|------|------|
| 登录/注册 | 5-10 次/15 分钟 | 防止暴力破解 |
| API 调用 | 100-1000 次/分钟 | 正常使用 |
| 文件上传 | 10 次/小时 | 防止滥用存储 |
| 发送邮件 | 3-5 次/小时 | 防止垃圾邮件 |

---

### 7. 错误消息安全

#### 常见错误

```javascript
// ❌ 错误示例：泄露敏感信息
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await db.query(
      `SELECT * FROM users WHERE id = ${req.params.id}`
    );
    res.json(user);
  } catch (error) {
    // 暴露数据库结构！
    res.status(500).json({
      error: 'Database error',
      details: error.message,
      query: error.query // 暴露 SQL 查询
    });
  }
});

// ✅ 正确示例：友好的错误消息
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await db.query(
      'SELECT * FROM users WHERE id = ?',
      [req.params.id]
    );
    res.json(user);
  } catch (error) {
    // 记录详细错误到日志
    logger.error('Database error', {
      error: error.message,
      query: error.query,
      userId: req.params.id
    });

    // 返回通用错误给用户
    res.status(500).json({
      error: '服务器错误，请稍后重试'
    });
  }
});
```

#### 错误消息原则

| 环境 | 错误详细程度 | 示例 |
|------|-------------|------|
| **开发环境** | 详细 | `Error: SELECT failed on column 'email'` |
| **生产环境** | 通用 | `服务器错误，请稍后重试` |

---

## 密钥管理 (Secret Management)

### 环境变量设置

#### 创建 .env 文件

```bash
# .env - 环境变量配置文件
# ⚠️ 重要：此文件不应该提交到 Git！

# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
DB_PASSWORD=secretpassword

# API 密钥
STRIPE_API_KEY=sk_live_xxxxx
SENDGRID_API_KEY=SG.xxxxx

# JWT 密钥
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=7d

# 应用配置
NODE_ENV=production
PORT=3000
```

#### 确保 .env 不被提交

```bash
# .gitignore - Git 忽略文件配置

# 环境变量文件
.env
.env.local
.env.production
.env.*.local

# 但保留示例文件
# .env.example 应该提交到 Git
```

#### 创建 .env.example（提交到 Git）

```bash
# .env.example - 环境变量示例文件
# 此文件应该提交到 Git，作为模板

# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
DB_PASSWORD=your-password-here

# API 密钥
STRIPE_API_KEY=your-stripe-key
SENDGRID_API_KEY=your-sendgrid-key

# JWT 密钥
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=7d

# 应用配置
NODE_ENV=development
PORT=3000
```

### 启动时验证

```javascript
// config/env.js - 环境变量验证
import dotenv from 'dotenv';

// 加载 .env 文件
dotenv.config();

// 必需的环境变量
const required = [
  'DATABASE_URL',
  'JWT_SECRET',
  'STRIPE_API_KEY'
];

// 检查所有必需的环境变量
for (const key of required) {
  if (!process.env[key]) {
    throw new Error(`❌ 缺少必需的环境变量: ${key}`);
  }
}

// 导出配置
export const config = {
  databaseUrl: process.env.DATABASE_URL,
  jwtSecret: process.env.JWT_SECRET,
  stripeApiKey: process.env.STRIPE_API_KEY,
  port: parseInt(process.env.PORT || '3000'),
  nodeEnv: process.env.NODE_ENV || 'development'
};

// 应用启动时立即检查
import { config } from './config/env.js';
console.log('✅ 环境变量验证通过');
```

### 密钥轮换 (Key Rotation)

#### 什么是密钥轮换？

定期更换密钥，减少密钥泄露的风险。

#### 轮换策略

```
旧密钥（已泄露风险） → 过渡期（新旧都有效） → 新密钥（唯一有效）
   2024-01-01            2024-01-15              2024-02-01
```

#### 实现示例

```javascript
// 支持多个 JWT 密钥
const JWT_KEYS = {
  current: process.env.JWT_SECRET, // 当前密钥
  previous: process.env.JWT_SECRET_OLD // 旧密钥（过渡期使用）
};

// 验证时尝试所有密钥
function verifyToken(token) {
  // 先尝试当前密钥
  try {
    return jwt.verify(token, JWT_KEYS.current);
  } catch (error) {
    // 如果失败，尝试旧密钥
    return jwt.verify(token, JWT_KEYS.previous);
  }
}

// 签发时只使用当前密钥
function signToken(payload) {
  return jwt.sign(payload, JWT_KEYS.current);
}
```

---

## 安全响应协议

### 发现安全问题时的处理流程

```
┌─────────────────────────────────────┐
│  发现安全问题                        │
└──────────┬──────────────────────────┘
           │
           ▼
    ┌──────────────┐
    │  1. 立即停止  │  ← 停止所有开发工作
    └──────┬───────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  2. 评估风险等级              │
    │  - 🔴 严重：立即处理          │
    │  - 🟠 高危：当天处理          │
    │  - 🟡 中危：本周处理          │
    └──────┬───────────────────────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  3. 使用 security-reviewer    │
    │     代理进行全面分析          │
    └──────┬───────────────────────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  4. 修复所有严重问题          │
    │     （在继续其他工作之前）    │
    └──────┬───────────────────────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  5. 轮换暴露的密钥            │
    └──────┬───────────────────────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  6. 审查整个代码库            │
    │     查找类似问题              │
    └──────┬───────────────────────┘
           │
           ▼
    ┌──────────────────────────────┐
    │  7. 记录和预防                │
    │     - 更新文档                │
    │     - 添加自动化检查          │
    │     - 培训团队成员            │
    └──────────────────────────────┘
```

### 使用 Security-Reviewer 代理

```bash
# 发现安全问题后
/security-reviewer "检查代码中的安全漏洞"

# 代理会：
# 1. 扫描所有代码文件
# 2. 识别常见安全漏洞
# 3. 按风险等级分类
# 4. 提供修复建议
```

---

## 安全检查清单（速查版）

### 提交前检查

```
□ 无硬编码密钥（API 密钥、密码、令牌）
□ 所有用户输入已验证
□ SQL 使用参数化查询
□ HTML 内容已清理（XSS 防护）
□ 表单有 CSRF token
□ 检查认证和授权
□ API 端点有速率限制
□ 错误消息不泄露敏感信息
□ .env 文件在 .gitignore 中
□ 敏感数据使用 HTTPS 传输
```

### 定期检查（每周/每月）

```
□ 更新依赖包（修复已知漏洞）
□ 审查访问日志（异常活动）
□ 轮换密钥（按计划）
□ 运行安全扫描工具
□ 审查用户权限
□ 备份数据（并测试恢复）
```

---

## 常见安全工具

### 依赖扫描

```bash
# npm audit - 检查 npm 包漏洞
npm audit

# npm audit fix - 自动修复可修复的漏洞
npm audit fix

# Snyk - 更全面的安全扫描
npx snyk test
```

### 代码扫描

```bash
# ESLint 安全插件
npm install --save-dev eslint-plugin-security

# 运行
eslint --plugin security src/

# Semgrep - 语义代码扫描
semgrep --config=auto
```

### 密钥检测

```bash
# gitleaks - 检测 Git 历史中的密钥
gitleaks detect

# truffleHog - 扫描密钥
trufflehog --regex --entropy=False /path/to/repo
```

---

## 常见问题 (FAQ)

### Q1: 如何判断某个信息是否应该作为环境变量？

**答**：问自己三个问题：
1. 这是敏感信息吗？（密钥、密码、令牌）→ 环境变量
2. 这会因环境不同而变化吗？（开发/测试/生产）→ 环境变量
3. 这可能需要在不修改代码的情况下更改吗？→ 环境变量

### Q2: .env 文件应该提交到 Git 吗？

**答**：
- **不应该**：`.env` 文件包含真实密钥
- **应该**：`.env.example` 文件（模板，不含真实密钥）

### Q3: 如果不小心提交了密钥怎么办？

**答**：立即行动！
1. **轮换密钥**：使泄露的密钥失效
2. **从 Git 历史中删除**：使用 `git filter-branch` 或 `BFG Repo-Cleaner`
3. **检查访问日志**：查看是否有异常访问
4. **通知用户**：如果数据可能泄露

### Q4: HTTPS 和安全有什么关系？

**答**：
- **HTTPS**：加密传输数据，防止中间人攻击
- **仍然需要其他安全措施**：HTTPS 不防 XSS、不防 SQL 注入
- **最佳实践**：HTTPS + 输入验证 + 认证授权

### Q5: 小项目也需要这些安全措施吗？

**答**：是的！
- **从小做起**：养成安全习惯比后期修复更容易
- **成本低**：预防漏洞的成本远低于修复的代价
- **用户信任**：即使用户少，也要保护他们的数据

---

## 总结

### 安全原则速记表

| 原则 | 关键点 | 记忆口诀 |
|------|--------|----------|
| **永不信任输入** | 验证所有外部数据 | 输入皆可疑，验证放第一 |
| **最小权限原则** | 只给必要的权限 | 权限最小够用即可 |
| **纵深防御** | 多层安全措施 | 多层防护，层层把关 |
| **密钥管理** | 使用环境变量 | 密钥不进码，环境变量存 |
| **及时响应** | 发现问题立即处理 | 安全无小事，响应要迅速 |

### 安全文档推荐

- [OWASP Top 10](https://owasp.org/www-project-top-ten/) - 最常见的安全风险
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/) - 安全防护指南
- [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security) - Web 安全最佳实践

记住：安全是一个过程，不是一次性任务！
