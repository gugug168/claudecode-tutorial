# 测试要求 (Testing Requirements)

> **规则用途**：定义测试要求和 TDD 工作流
>
> **适用场景**：编写测试、实现新功能、排查测试失败时参考
>
> **核心能力**：80% 覆盖率、TDD 工作流、测试故障排除
>
> **适用范围**：通用规则

---

## 最低测试覆盖率：80%

### 什么是测试覆盖率？

测试覆盖率衡量你的代码有多少被测试执行过。想象你在检查房子：
- **覆盖率 100%**：检查了每个房间、每个角落
- **覆盖率 50%**：只检查了一半的房间
- **覆盖率 0%**：完全没有检查（很危险！）

### 为什么需要 80%？

```
覆盖率 代码质量    风险级别   推荐场景
0%     无法保证    极高       个人项目原型
50%    基本保证    高         小型工具
80%    较高保证    中         生产代码（推荐）
100%   完全保证    低         关键系统
```

80% 是一个平衡点：
- 覆盖了大部分关键逻辑
- 不会过度追求完美的数字
- 保留了灵活空间（如错误处理分支）

### 三种必需的测试类型

#### 1. 单元测试 (Unit Tests)

**测试范围**：单个函数、工具类、组件

**比喻**：测试电视机的遥控器
- 测试每个按钮是否工作
- 不依赖其他设备
- 快速且独立

**示例**：
```javascript
// 测试一个简单的工具函数
describe('formatCurrency', () => {
  it('should format positive numbers', () => {
    expect(formatCurrency(1234.56)).toBe('¥1,234.56');
  });

  it('should handle zero', () => {
    expect(formatCurrency(0)).toBe('¥0.00');
  });

  it('should handle negative numbers', () => {
    expect(formatCurrency(-100)).toBe('-¥100.00');
  });
});
```

#### 2. 集成测试 (Integration Tests)

**测试范围**：API 端点、数据库操作、多个模块协作

**比喻**：测试电视机的完整功能
- 测试遥控器 → 电视 ↔ 电缆盒
- 测试设备之间的连接
- 验证数据正确传递

**示例**：
```javascript
// 测试 API 端点
describe('POST /api/users', () => {
  it('should create a new user', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({
        name: '张三',
        email: 'zhangsan@example.com'
      })
      .expect(201);

    expect(response.body).toHaveProperty('id');
    expect(response.body.name).toBe('张三');

    // 验证数据库中确实创建了用户
    const user = await db.users.findById(response.body.id);
    expect(user).not.toBeNull();
  });
});
```

#### 3. E2E 测试 (End-to-End Tests)

**测试范围**：完整的用户流程

**比喻**：测试从开机到看节目的完整流程
- 打开电视
- 切换到正确的输入
- 选择频道
- 确认画面和声音正常

**示例**：
```javascript
// 测试完整的用户注册流程
describe('User Registration Flow', () => {
  it('should complete registration successfully', async () => {
    // 1. 访问注册页面
    await page.goto('/register');

    // 2. 填写表单
    await page.fill('#name', '李四');
    await page.fill('#email', 'lisi@example.com');
    await page.fill('#password', 'SecurePass123');

    // 3. 提交表单
    await page.click('button[type="submit"]');

    // 4. 验证重定向到欢迎页面
    await expect(page).toHaveURL('/welcome');

    // 5. 验证显示欢迎消息
    await expect(page.locator('h1')).toContainText('欢迎，李四');
  });
});
```

### 测试类型对比

| 特性 | 单元测试 | 集成测试 | E2E 测试 |
|------|----------|----------|----------|
| **速度** | 毫秒级 | 秒级 | 分钟级 |
| **成本** | 低 | 中 | 高 |
| **维护** | 容易 | 中等 | 困难 |
| **覆盖率** | 细粒度 | 模块级 | 系统级 |
| **数量** | 大量 | 适量 | 少量 |
| **运行频率** | 每次保存 | 每次 commit | 每次 PR |

**推荐比例**：70% 单元测试 + 20% 集成测试 + 10% E2E 测试

---

## 测试驱动开发 (Test-Driven Development)

### 什么是 TDD？

TDD 是一种开发方法论：**先写测试，再写代码**

比喻：先建好质检标准，再生产产品
```
传统方式：生产产品 → 发现问题 → 修补问题 → 再测试
TDD 方式：制定标准 → 生产产品 → 自动通过质检
```

### TDD 红绿灯循环

```
┌─────────────────────────────────────────────────────┐
│  TDD 开发循环                                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│  🔴 RED（红色）                                       │
│  └─ 编写一个失败的测试                                 │
│     └─ 描述你想要的功能                               │
│                                                     │
│  ────►                                               │
│                                                     │
│  🟢 GREEN（绿色）                                     │
│  └─ 编写最简单的代码让测试通过                         │
│     └─ 可以写"假"代码（如返回固定值）                 │
│                                                     │
│  ────►                                               │
│                                                     │
│  🔵 IMPROVE（改进/重构）                              │
│  └─ 优化代码，删除重复                                │
│     └─ 测试仍然是绿色的                              │
│                                                     │
│  ────► 回到 RED（下一个功能）                         │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### TDD 实战示例

#### 阶段 1：RED - 编写失败的测试

```javascript
// calculator.test.js
describe('Calculator', () => {
  describe('add', () => {
    it('should add two positive numbers', () => {
      // 还没有实现 add 函数，这个测试会失败
      expect(add(2, 3)).toBe(5);
    });
  });
});
```

**运行测试**：
```bash
npm test

# 结果：❌ FAILED
# ReferenceError: add is not defined
```

#### 阶段 2：GREEN - 编写最简单的实现

```javascript
// calculator.js
function add(a, b) {
  // 最简单的实现，让测试通过
  return 5; // 硬编码，只为了让这个测试通过
}
```

**运行测试**：
```bash
npm test

# 结果：✅ PASSED
# 测试通过了！
```

#### 阶段 3：IMPROVE - 重构为真实实现

```javascript
// calculator.js
function add(a, b) {
  return a + b; // 真实实现
}
```

**运行测试**：
```bash
npm test

# 结果：✅ PASSED
# 测试仍然通过！
```

#### 添加更多测试（回到 RED）

```javascript
describe('Calculator', () => {
  describe('add', () => {
    it('should add two positive numbers', () => {
      expect(add(2, 3)).toBe(5);
    });

    // 新测试（RED 阶段）
    it('should handle negative numbers', () => {
      expect(add(-5, 3)).toBe(-2);
    });

    it('should handle zero', () => {
      expect(add(0, 0)).toBe(0);
    });

    it('should handle decimals', () => {
      expect(add(0.1, 0.2)).toBeCloseTo(0.3);
    });
  });
});
```

**优化实现**：
```javascript
function add(a, b) {
  // 处理所有情况的真实实现
  return a + b;
}
```

### TDD 的好处

| 好处 | 说明 |
|------|------|
| **安全重构** | 有测试保护，改动不会破坏功能 |
| **活文档** | 测试就是最好的使用示例 |
| **设计更好** | 先考虑如何使用，再考虑如何实现 |
| **调试更快** | 问题立即发现，不用等到测试阶段 |
| **信心满满** | 有测试覆盖，发布不慌张 |

### TDD 常见误区

| 误区 | 真相 |
|------|------|
| "TDD 太慢了" | 初期慢，长期快（减少调试时间） |
| "测试很难写" | 先写测试反而更容易（接口清晰） |
| "100% 覆盖率" | 80% 足够，不要过度测试 |
| "TDD 适用于所有情况" | 探索性开发可以先写代码再补测试 |

---

## 测试失败故障排除

### 故障排除流程图

```
测试失败
   │
   ├─► 是否是测试本身的问题？
   │   └─ 是 → 修复测试代码
   │
   ├─► 是否是 mock 配置错误？
   │   └─ 是 → 修正 mock 数据
   │
   ├─► 是否是测试隔离问题？
   │   └─ 是 → 添加清理逻辑
   │
   └─► 是实现代码的问题吗？
       └─ 是 → 修复实现代码
```

### 常见问题与解决方案

#### 问题 1：测试隔离失败

**症状**：单个测试通过，一起运行就失败

**原因**：测试之间相互影响

**解决方案**：
```javascript
describe('UserService', () => {
  beforeEach(() => {
    // 每个测试前清理数据库
    db.clear();
  });

  afterEach(() => {
    // 每个测试后清理
    db.clear();
  });

  it('should create user', () => {
    // 这个测试不影响其他测试
    const user = userService.create({ name: 'Alice' });
    expect(user.name).toBe('Alice');
  });
});
```

#### 问题 2：Mock 配置错误

**症状**：Mock 的函数没有被调用，或者返回了错误的数据

**解决方案**：
```javascript
// 错误的 mock
jest.mock('./api');
import { api } from './api';

api.getUser.mockReturnValue(mockUser); // ❌ 时机太晚

// 正确的 mock
jest.mock('./api', () => ({
  api: {
    getUser: jest.fn()
  }
}));

import { api } from './api';
api.getUser.mockReturnValue(mockUser); // ✅ 正确时机
```

#### 问题 3：异步测试超时

**症状**：测试超时失败

**解决方案**：
```javascript
// 必须返回 Promise 或使用 async/await
it('should fetch user', async () => {
  const user = await fetchUser(1);
  expect(user).toBeDefined();
});

// 或者使用 done 回调
it('should fetch user', (done) => {
  fetchUser(1).then(user => {
    expect(user).toBeDefined();
    done(); // 必须调用 done
  });
});
```

#### 问题 4：测试实现还是测试代码？

**决策树**：
```
测试失败
  │
  ├─ 需求理解错误？ → 修复测试
  │   例：测试要求返回 "success" 但实际需求是 "passed"
  │
  ├─ 测试代码写错？ → 修复测试
  │   例：断言写错了 expect(a).toBe(b) 应该是 expect(b).toBe(a)
  │
  └─ 功能确实没实现？ → 修复实现
      例：功能逻辑有 bug，或者还没实现这个功能
```

### 使用 TDD Guide 代理

```bash
# 当测试失败时，调用 tdd-guide 代理
/tdd-guide "我的测试失败了，错误信息是..."

# 代理会帮你：
# 1. 分析错误信息
# 2. 识别问题类型
# 3. 提供解决方案
# 4. 编写修复代码
```

---

## 测试最佳实践

### 1. 测试命名（AAA 模式）

```javascript
// 好的命名：清晰描述场景
describe('UserService.createUser', () => {
  it('should create user with valid data', () => {
    // Arrange（准备）
    const userData = { name: 'Alice', email: 'alice@example.com' };

    // Act（执行）
    const user = userService.createUser(userData);

    // Assert（断言）
    expect(user.id).toBeDefined();
    expect(user.name).toBe('Alice');
  });
});
```

### 2. 一个测试只验证一件事

```javascript
// 坏的做法：一个测试验证太多
it('should handle all user operations', () => {
  const user = userService.create(data);
  const updated = userService.update(user.id, newData);
  const deleted = userService.delete(user.id);
  // 太多逻辑，难以定位问题
});

// 好的做法：每个测试专注一件事
it('should create user', () => {
  const user = userService.create(data);
  expect(user).toBeDefined();
});

it('should update user', () => {
  // ...
});

it('should delete user', () => {
  // ...
});
```

### 3. 使用有意义的断言消息

```javascript
// 好的做法：自定义断言消息
expect(user.age).toBeGreaterThanOrEqual(18, '用户必须年满18岁');
expect(email).toMatch(/^[^\s@]+@[^\s@]+\.[^\s@]+$/, '邮箱格式无效');

// 失败时会显示：
// Error: 用户必须年满18岁
// Expected: >= 18
// Received: 16
```

### 4. 避免测试实现细节

```javascript
// 坏的做法：测试内部实现
it('should set internal flag', () => {
  user.setFlag('internal');
  expect(user.internalFlag).toBe(true); // 测试私有属性
});

// 好的做法：测试公开行为
it('should activate premium features', () => {
  user.upgradeToPremium();
  expect(user.hasPremiumAccess()).toBe(true); // 测试公开方法
});
```

---

## 测试框架选择

### JavaScript/TypeScript

| 框架 | 适用场景 | 特点 |
|------|----------|------|
| **Jest** | 通用测试 | 零配置、快照测试、流行 |
| **Vitest** | Vite 项目 | 快速、兼容 Jest |
| **Mocha** | 传统项目 | 灵活、需要配置 |
| **Playwright** | E2E 测试 | 跨浏览器、快速 |

### Python

| 框架 | 适用场景 | 特点 |
|------|----------|------|
| **pytest** | 通用测试 | 简洁、插件丰富 |
| **unittest** | 标准库 | 内置、类似 JUnit |

---

## 常见问题 (FAQ)

### Q1: 是否应该为所有代码写测试？

**答**：不是。优先级：
1. 核心业务逻辑（必须）
2. 公共 API（必须）
3. 复杂算法（必须）
4. 工具函数（推荐）
5. 配置文件（可选）
6. 简单的 getter/setter（不必要）

### Q2: 测试代码算不算工作量？

**答**：当然算！实际上：
- 测试代码 = 生产代码
- 好的测试就是文档
- 测试减少调试时间
- TDD 让开发更高效

### Q3: 如何测试私有方法？

**答**：不要直接测试私有方法！
- 通过公开方法间接测试
- 如果私有方法太复杂，考虑提取为独立模块
- 私有方法是实现细节，应该可以随意重构而不破坏测试

### Q4: 80% 覆盖率够吗？

**答**：
- **够用**：对于大部分项目
- **不够**：关键系统（医疗、金融）可能需要 95%+
- **不要盲目追求**：100% 往往意味着测试了不重要的代码

### Q5: Mock 是什么？什么时候用？

**答**：
- **什么是 Mock**：模拟外部依赖的假对象
- **什么时候用**：
  - 测试时不想真的调用数据库
  - 测试时不想真的发送网络请求
  - 模拟极端情况（如网络错误）

```javascript
// 示例：Mock 数据库调用
jest.mock('./database');
import { db } from './database';

db.users.findById.mockResolvedValue({ id: 1, name: 'Alice' });

// 测试不会真的访问数据库
const user = await userService.getUser(1);
expect(user.name).toBe('Alice');
```

---

## 总结

### 测试要点速查表

| 要点 | 关键点 | 记忆口诀 |
|------|--------|----------|
| **覆盖率** | 80% 是平衡点 | 八成足够，不必完美 |
| **测试类型** | 单元 70%、集成 20%、E2E 10% | 金字塔结构 |
| **TDD** | RED → GREEN → IMPROVE | 先测后码，循环改进 |
| **故障排除** | 先检查测试，再检查实现 | 疑罪从有，测代码先 |
| **最佳实践** | AAA 模式、清晰命名、单一职责 | 测试如文档，命名要清楚 |

### TDD 心法

```markdown
当你不知道从何开始时：
1. 先写一个失败的测试（RED）
2. 写最简单的代码让测试通过（GREEN）
3. 重构和优化（IMPROVE）
4. 重复循环

记住：
- 测试是安全的网，不是累赘
- 测试是文档，不是负担
- 测试让你更快，不是更慢
```

遵循这些原则，你的代码将更健壮、更易维护！
