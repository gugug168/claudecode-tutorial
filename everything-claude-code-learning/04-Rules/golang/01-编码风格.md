# Go 编码风格规范

> 本文件扩展了 [common/coding-style.md](../common/coding-style.md)，添加了 Go 语言特定的内容。

## 适用范围

本规则适用于以下文件：
- 所有 `.go` 源文件
- `go.mod` 模块配置文件
- `go.sum` 依赖锁定文件

---

## 一、代码格式化（Formatting）

### 什么是代码格式化？

代码格式化就是让代码的排版、缩进、空格等保持统一的风格，这样代码更容易阅读和维护。

### Go 语言的格式化工具

在 Go 语言中，代码格式化非常简单，有两个强制性工具：

| 工具名称 | 功能 | 什么时候用 |
|---------|------|-----------|
| **gofmt** | 标准代码格式化工具 | 所有 Go 代码必须通过 |
| **goimports** | 自动管理 import 导入 | 需要自动整理包导入时 |

### 使用方法

```bash
# 格式化单个文件
gofmt -w main.go

# 格式化整个项目
gofmt -w ./...

# 使用 goimports（更智能，会自动添加/删除导入）
goimports -w main.go
```

### 重要提示

> ⚠️ **gofmt 和 goimports 是强制性的** - 无需争论代码风格，直接用工具统一即可。

---

## 二、设计原则（Design Principles）

### 原则 1：接受接口，返回结构体

这是什么意思呢？

```go
// ✅ 好的做法：函数接受接口参数
func ProcessData(data io.Reader) error {
    // io.Reader 是接口，可以传入任何实现了 Read 方法的类型
}

// ❌ 不好的做法：函数接受具体的结构体
func ProcessData(data *File) error {
    // 只能传 File 类型，不够灵活
}
```

**为什么这样做？**

- **灵活性高**：调用者可以传入任何实现了接口的类型
- **易于测试**：测试时可以传入 mock 对象
- **解耦合**：不依赖具体实现

### 原则 2：保持接口小（1-3 个方法）

```go
// ✅ 好的做法：接口只包含一个方法
type Reader interface {
    Read(p []byte) (n int, err error)
}

// ✅ 也可以：接口包含 2-3 个相关方法
type WriteCloser interface {
    Write(p []byte) (n int, err error)
    Close() error
}

// ❌ 不好的做法：接口太大，包含太多方法
type HugeInterface interface {
    Method1()
    Method2()
    Method3()
    Method4()
    Method5()
    // ... 十几个方法
}
```

**为什么接口要小？**

- **易于实现**：接口越小，实现起来越简单
- **职责单一**：每个接口专注于一个功能
- **可组合性**：多个小接口可以组合使用

---

## 三、错误处理（Error Handling）

### Go 语言的错误处理哲学

在 Go 语言中，错误是显式处理的，不像其他语言使用异常。

### 永远用上下文包装错误

当错误发生时，不要只是简单地返回原始错误，要添加上下文信息：

```go
// ❌ 不好的做法：直接返回原始错误
if err != nil {
    return err
}

// ✅ 好的做法：用上下文包装错误
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}

// ✅ 更好的做法：多层包装时添加更多上下文
if err != nil {
    return fmt.Errorf("failed to create user for ID %s: %w", userID, err)
}
```

### 为什么使用 `%w` 而不是 `%v`？

```go
// %w：保留原始错误，可以用于错误检查（errors.Is）
err := fmt.Errorf("context: %w", originalErr)
if errors.Is(err, originalErr) {
    // 可以检测到原始错误
}

// %v：只是转换为字符串，无法进行错误检查
err := fmt.Errorf("context: %v", originalErr)
if errors.Is(err, originalErr) {
    // 永远不会匹配
}
```

### 错误处理示例

```go
package main

import (
    "fmt"
    "os"
)

func readFile(filename string) ([]byte, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // 添加上下文信息
        return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    return data, nil
}

func main() {
    data, err := readFile("config.json")
    if err != nil {
        // 打印带有完整上下文的错误信息
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    fmt.Printf("Read %d bytes\n", len(data))
}
```

---

## 四、参考资源（Reference）

### 技能参考

想学习更多 Go 语言的惯用法和模式？

参见技能：`golang-patterns`

这个技能包含了：
- 全面的 Go 语言惯用法
- 常见的设计模式
- 并发编程模式
- 错误处理最佳实践
- 包组织结构建议

---

## 快速检查清单

在提交 Go 代码前，确保：

- [ ] 运行了 `gofmt -w ./...` 格式化代码
- [ ] 运行了 `goimports -w ./...` 整理导入
- [ ] 所有错误都用上下文包装（使用 `%w`）
- [ ] 函数参数优先使用接口而非结构体
- [ ] 接口保持小（1-3 个方法）

---

## 常见问题（FAQ）

**Q: 我应该手动格式化代码吗？**

A: 不需要！让 `gofmt` 和 `goimports` 自动处理。你只需要专注于写代码逻辑。

**Q: 接口应该在实现它的包里定义吗？**

A: 不！接口应该在**使用它的包**里定义，而不是实现它的包。这叫做"接口隔离原则"。

**Q: 什么时候应该创建新接口？**

A: 当你需要：
1. 解耦两个模块
2. 编写单元测试需要 mock
3. 让代码更灵活、可测试

**Q: 错误包装太多层会有问题吗？**

A: 适度包装是好的。通常每层添加一个上下文即可，不要过度包装。
