# Go 安全规范

> 本文件扩展了 [common/security.md](../common/security.md)，添加了 Go 语言特定的内容。

## 适用范围

本规则适用于以下文件：
- 所有 `.go` 源文件
- `go.mod` 模块配置文件
- `go.sum` 依赖锁定文件

---

## 一、密钥管理（Secret Management）

### 为什么密钥管理很重要？

密钥（如 API 密钥、数据库密码、访问令牌）是系统的钥匙。如果泄露，攻击者就能访问你的敏感资源。

### ❌ 不安全的做法

```go
// ❌ 永远不要这样做！
const API_KEY = "sk-1234567890abcdef"

// ❌ 也不要这样做！
var apiKey = "sk-1234567890abcdef"

// ❌ 更不要把密钥提交到 Git 仓库！
```

### ✅ 正确的做法：从环境变量读取

```go
package main

import (
    "log"
    "os"
)

func main() {
    // 从环境变量获取密钥
    apiKey := os.Getenv("OPENAI_API_KEY")

    // 检查密钥是否存在
    if apiKey == "" {
        log.Fatal("OPENAI_API_KEY not configured")
    }

    // 现在可以安全使用 apiKey
    // ...
}
```

### 如何设置环境变量？

**Windows (PowerShell):**
```powershell
$env:OPENAI_API_KEY="sk-your-key-here"
go run main.go
```

**Linux/macOS:**
```bash
export OPENAI_API_KEY="sk-your-key-here"
go run main.go
```

**使用 .env 文件（开发环境）:**

```go
// 安装：go get github.com/joho/godotenv
package main

import (
    "log"
    "os"

    "github.com/joho/godotenv"
)

func main() {
    // 加载 .env 文件
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }

    apiKey := os.Getenv("OPENAI_API_KEY")
    if apiKey == "" {
        log.Fatal("OPENAI_API_KEY not configured")
    }

    // ...
}
```

### .gitignore 配置

确保 `.env` 文件不会被提交到 Git：

```text
# .gitignore
.env
.env.local
.env.*.local
```

### 密钥管理最佳实践

| 场景 | 推荐方案 |
|------|---------|
| **本地开发** | `.env` 文件（加入 .gitignore） |
| **生产环境** | 环境变量或密钥管理服务（如 AWS Secrets Manager） |
| **CI/CD** | CI 平台的密钥管理功能 |
| **容器化部署** | 容器的环境变量或密钥卷 |

---

## 二、安全扫描（Security Scanning）

### 什么是静态安全分析？

静态安全分析是在不运行代码的情况下，通过扫描源代码来发现潜在的安全问题。

### gosec：Go 语言安全扫描工具

**gosec** 是 Go 语言的安全扫描工具，可以检测常见的安全漏洞。

### 安装 gosec

```bash
# 安装
go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

# 验证安装
gosec -version
```

### 使用 gosec 扫描代码

```bash
# 扫描当前目录及其子目录
gosec ./...

# 扫描特定包
gosec ./pkg/...

# 输出 JSON 格式报告
gosec -fmt json -output results.json ./...

# 输出 HTML 报告
gosec -fmt html -output results.html ./...
```

### gosec 检测的问题类型

| 问题类型 | 说明 | 示例 |
|---------|------|------|
| **硬编码密钥** | 代码中包含敏感信息 | `apiKey = "sk-123"` |
| **SQL 注入** | 不安全的 SQL 查询 | `"SELECT * FROM users WHERE id=" + id` |
| **弱加密** | 使用不安全的加密算法 | 使用 MD5 而非 SHA256 |
| **不安全的随机数** | 使用伪随机数用于安全场景 | 使用 `math/rand` 而非 `crypto/rand` |
| **文件遍历** | 未验证的文件路径操作 | `os.Open("../" + filename)` |
| **命令注入** | 不安全的命令执行 | `exec.Command("sh", userInput)` |

### 示例：gosec 检测到的问题

```go
// ❌ gosec 会检测到硬编码密钥
package main

func main() {
    apiKey := "sk-1234567890abcdef"  // 警告：硬编码密钥
    // ...
}
```

修复后：

```go
// ✅ 使用环境变量
package main

import "os"

func main() {
    apiKey := os.Getenv("API_KEY")
    // ...
}
```

### 集成到 CI/CD

在 CI/CD 流程中加入安全扫描：

```yaml
# .github/workflows/security.yml
name: Security Scan

on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run gosec
        run: |
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
          gosec -fmt sarif -output results.sarif ./...
```

---

## 三、上下文和超时控制（Context & Timeouts）

### 为什么需要超时控制？

在处理网络请求、数据库查询或文件 I/O 时，可能会因为各种原因导致操作挂起（没有响应）。如果没有超时控制，程序可能会永久等待。

### Go 的 context 包

Go 的 `context` 包提供了超时控制、取消信号和请求作用域值的能力。

### 基本使用：带超时的上下文

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func fetchData(ctx context.Context) (string, error) {
    // 模拟长时间操作
    select {
    case <-time.After(5 * time.Second):
        return "data", nil
    case <-ctx.Done():
        return "", ctx.Err()  // 超时或取消
    }
}

func main() {
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)

    // 确保在函数退出时取消上下文，释放资源
    defer cancel()

    result, err := fetchData(ctx)
    if err != nil {
        fmt.Println("Error:", err)  // Error: context deadline exceeded
        return
    }

    fmt.Println("Result:", result)
}
```

### 使用 defer cancel() 的重要性

```go
// ✅ 好的做法：使用 defer
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
defer cancel()  // 确保资源被释放

// ... 使用 ctx ...

// ❌ 不好的做法：忘记 cancel
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
// 忘记调用 cancel()，可能导致资源泄漏
```

### 为什么需要 defer cancel()？

1. **释放资源**：即使操作提前完成，也需要通知系统释放相关资源
2. **防止泄漏**：如果不 cancel，相关资源可能不会被释放
3. **最佳实践**：Go 官方推荐的惯用法

### HTTP 请求的超时控制

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

func main() {
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // 创建请求
    req, err := http.NewRequestWithContext(ctx, "GET", "https://example.com", nil)
    if err != nil {
        panic(err)
    }

    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("Request failed:", err)
        return
    }
    defer resp.Body.Close()

    fmt.Println("Request succeeded")
}
```

### 不同类型的上下文

| 上下文类型 | 用途 | 示例 |
|-----------|------|------|
| **context.Background()** | 根上下文，永不取消 | 作为顶级上下文 |
| **context.TODO()** | 未确定时使用 | 临时占位符 |
| **context.WithTimeout()** | 带超时的上下文 | 网络请求、数据库查询 |
| **context.WithDeadline()** | 带截止时间的上下文 | 定时任务 |
| **context.WithCancel()** | 可手动取消的上下文 | 长时间运行的任务 |
| **context.WithValue()** | 传递请求作用域的值 | 传递请求 ID、用户信息 |

### 超时时间的选择

| 操作类型 | 推荐超时时间 |
|---------|-------------|
| **HTTP API 调用** | 5-30 秒 |
| **数据库查询** | 3-10 秒 |
| **文件 I/O** | 5-60 秒 |
| **微服务调用** | 3-10 秒 |

> ⚠️ **始终使用 context.Context 进行超时控制** - 这能防止资源泄漏和程序挂起。

---

## 四、常见安全漏洞及防范

### 1. SQL 注入

```go
// ❌ 不安全：字符串拼接
query := "SELECT * FROM users WHERE id=" + userID
db.Exec(query)

// ✅ 安全：使用参数化查询
query := "SELECT * FROM users WHERE id=?"
db.QueryRow(query, userID)
```

### 2. 命令注入

```go
// ❌ 不安全：直接使用用户输入
cmd := exec.Command("ls", userInput)

// ✅ 安全：验证和清理输入
if !isValidFilename(userInput) {
    return errors.New("invalid filename")
}
cmd := exec.Command("ls", filepath.Clean(userInput))
```

### 3. 路径遍历

```go
// ❌ 不安全：未验证路径
filePath := "/var/data/" + filename
os.Open(filePath)  // 可能访问 ../etc/passwd

// ✅ 安全：验证和规范化路径
filePath := filepath.Join("/var/data", filepath.Clean(filename))
if !strings.HasPrefix(filePath, "/var/data/") {
    return errors.New("invalid path")
}
```

### 4. 不安全的随机数

```go
// ❌ 不安全：使用伪随机数（可预测）
import "math/rand"
rand.Seed(time.Now().Unix())
token := rand.Int()  // 可预测，不能用于安全场景

// ✅ 安全：使用加密安全的随机数
import "crypto/rand"
b := make([]byte, 16)
_, err := rand.Read(b)  // 加密安全的随机数
```

---

## 五、安全检查清单

在部署 Go 应用前，确保：

- [ ] 所有密钥从环境变量读取，不在代码中硬编码
- [ ] 运行了 `gosec ./...` 并修复了所有高风险问题
- [ ] 所有外部请求都有超时控制（使用 context）
- [ ] 使用了参数化查询防止 SQL 注入
- [ ] 验证了用户输入，防止命令注入和路径遍历
- [ ] 使用了 HTTPS 而非 HTTP
- [ ] .env 文件已加入 .gitignore
- [ ] 依赖包定期更新，修复已知漏洞

---

## 常见问题（FAQ）

**Q: gosec 检测到的问题必须全部修复吗？**

A: 高风险问题必须修复。对于中低风险问题，需要评估实际情况。有时某些"问题"在特定场景下是可以接受的。

**Q: 如何在 CI/CD 中集成安全扫描？**

A: 在 CI/CD 配置文件中添加 gosec 扫描步骤，并将结果作为 PR 检查的一部分。

**Q: context.WithTimeout 的超时时间应该设置多少？**

A: 取决于操作类型。通常网络请求 5-30 秒，数据库查询 3-10 秒。太短可能导致正常操作失败，太长可能导致资源浪费。

**Q: 为什么需要 defer cancel()，即使操作已经完成？**

A: `defer cancel()` 确保在任何情况下（正常返回、panic、提前退出）都会释放资源。这是一个重要的安全措施。

**Q: 如何检查依赖包的安全漏洞？**

A: 使用 `go list -json -m all | go run golang.org/x/vuln/cmd/govulncheck@latest` 检查已知漏洞。
