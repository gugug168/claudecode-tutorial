# Go 设计模式

> 本文件扩展了 [common/patterns.md](../common/patterns.md)，添加了 Go 语言特定的内容。

## 适用范围

本规则适用于以下文件：
- 所有 `.go` 源文件
- `go.mod` 模块配置文件
- `go.sum` 依赖锁定文件

---

## 一、函数式选项模式（Functional Options）

### 什么是函数式选项模式？

函数式选项模式是一种灵活的配置对象的方式。它让你可以：
- 逐步配置对象
- 只配置需要的选项
- 不用记住一堆构造函数参数

### 传统方法的问题

```go
// ❌ 不好的做法：多个构造函数
func NewServer() *Server
func NewServerWithPort(port int) *Server
func NewServerWithPortAndTimeout(port int, timeout time.Duration) *Server
func NewServerWithPortAndTimeoutAndLogger(port int, timeout time.Duration, logger Logger) *Server
// ... 无穷无尽的构造函数
```

或者使用配置结构体：

```go
// ⚠️ 可以，但不灵活
type Config struct {
    Port    int
    Timeout time.Duration
    Logger  Logger
}

func NewServer(config Config) *Server {
    // 必须提供所有配置
}

// 使用时
config := Config{
    Port:    8080,
    Timeout: 30 * time.Second,
    Logger:  nil,  // 必须提供，即使不想配置
}
```

### 函数式选项模式实现

```go
package server

import (
    "time"
)

// Server 是要配置的服务器
type Server struct {
    port    int
    timeout time.Duration
    logger  Logger
}

// Logger 是日志接口
type Logger interface {
    Log(msg string)
}

// Option 是配置选项的函数类型
type Option func(*Server)

// WithPort 配置端口号
func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

// WithTimeout 配置超时时间
func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

// WithLogger 配置日志记录器
func WithLogger(logger Logger) Option {
    return func(s *Server) {
        s.logger = logger
    }
}

// NewServer 创建新的服务器，应用所有选项
func NewServer(opts ...Option) *Server {
    // 设置默认值
    s := &Server{
        port:    8080,           // 默认端口
        timeout: 30 * time.Second, // 默认超时
        logger:  nil,            // 默认无日志
    }

    // 应用所有选项
    for _, opt := range opts {
        opt(s)
    }

    return s
}
```

### 使用示例

```go
package main

// 使用默认配置
s1 := NewServer()
// s1: port=8080, timeout=30s, logger=nil

// 只配置端口
s2 := NewServer(WithPort(9000))
// s2: port=9000, timeout=30s, logger=nil

// 配置端口和超时
s3 := NewServer(
    WithPort(9000),
    WithTimeout(60*time.Second),
)
// s3: port=9000, timeout=60s, logger=nil

// 配置所有选项
s4 := NewServer(
    WithPort(9000),
    WithTimeout(60*time.Second),
    WithLogger(myLogger),
)
// s4: port=9000, timeout=60s, logger=myLogger
```

### 函数式选项模式的优势

| 优势 | 说明 |
|------|------|
| **灵活** | 只配置需要的选项 |
| **可扩展** | 添加新选项不影响现有代码 |
| **可读** | 代码清晰，一看就懂 |
| **有默认值** | 不用配置也能使用 |
| **顺序无关** | 选项顺序不影响结果 |

### 实际应用示例

```go
// HTTP 客户端配置
type HTTPClient struct {
    timeout time.Duration
    retry   int
    headers map[string]string
}

type Option func(*HTTPClient)

func WithTimeout(t time.Duration) Option {
    return func(c *HTTPClient) { c.timeout = t }
}

func WithRetry(n int) Option {
    return func(c *HTTPClient) { c.retry = n }
}

func WithHeaders(headers map[string]string) Option {
    return func(c *HTTPClient) { c.headers = headers }
}

func NewHTTPClient(opts ...Option) *HTTPClient {
    c := &HTTPClient{
        timeout: 30 * time.Second,
        retry:   3,
        headers: make(map[string]string),
    }
    for _, opt := range opts {
        opt(c)
    }
    return c
}

// 使用
client := NewHTTPClient(
    WithTimeout(10*time.Second),
    WithRetry(5),
    WithHeaders(map[string]string{
        "User-Agent": "MyApp/1.0",
    }),
)
```

---

## 二、小接口原则（Small Interfaces）

### 什么是小接口原则？

Go 语言推崇**小而专注的接口**。接口应该在**使用它的地方**定义，而不是在实现它的地方定义。

### 标准库的例子

Go 标准库中充满了小接口的例子：

```go
// io.Reader：只需要一个方法
type Reader interface {
    Read(p []byte) (n int, err error)
}

// io.Writer：只需要一个方法
type Writer interface {
    Write(p []byte) (n int, err error)
}

// io.Closer：只需要一个方法
type Closer interface {
    Close() error
}

// 组合小接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

### 如何定义接口？

#### ❌ 不好的做法：在实现处定义大接口

```go
// 在实现包中定义
package storage

// 大接口
type Database interface {
    Query(query string) Result
    Execute(query string) error
    Begin() Transaction
    Close() error
    Ping() error
    Stats() Stats
    // ... 很多方法
}

type MySQL struct {
    // ...
}

func (m *MySQL) Query(query string) Result { ... }
func (m *MySQL) Execute(query string) error { ... }
// ... 实现所有方法
```

#### ✅ 好的做法：在使用处定义小接口

```go
// 在使用包中定义
package users

// 只定义需要的方法
type UserQuerier interface {
    Query(query string) Result
}

func GetUser(id int, db UserQuerier) *User {
    // 只需要 Query 方法
    result := db.Query("SELECT * FROM users WHERE id=" + id)
    // ...
}
```

### 小接口的优势

| 优势 | 说明 |
|------|------|
| **易于实现** | 接口越小，实现越简单 |
| **职责单一** | 每个接口专注于一个功能 |
| **可组合** | 多个小接口可以组合成大接口 |
| **易于测试** | 测试时只需要 mock 少量方法 |

### 实际应用示例

```go
// 用户服务需要的功能
package users

// 定义小接口
type UserStore interface {
    GetUser(id int) (*User, error)
    SaveUser(user *User) error
}

type Logger interface {
    Log(msg string)
}

type UserService struct {
    store  UserStore
    logger Logger
}

func NewUserService(store UserStore, logger Logger) *UserService {
    return &UserService{
        store:  store,
        logger: logger,
    }
}

// 实现
type MySQLUserStore struct {
    db *sql.DB
}

func (s *MySQLUserStore) GetUser(id int) (*User, error) {
    // MySQL 实现
}

func (s *MySQLUserStore) SaveUser(user *User) error {
    // MySQL 实现
}

// 也可以有其他实现
type MongoDBUserStore struct {
    client *mongo.Client
}

func (s *MongoDBUserStore) GetUser(id int) (*User, error) {
    // MongoDB 实现
}

func (s *MongoDBUserStore) SaveUser(user *User) error {
    // MongoDB 实现
}
```

---

## 三、依赖注入（Dependency Injection）

### 什么是依赖注入？

依赖注入是一种设计模式，它要求：
- **不自己创建依赖**（不用 `new` 或全局变量）
- **从外部接收依赖**（通过函数参数或结构体字段）

### 依赖注入的两种方式

#### 方式 1：构造函数注入

```go
package users

// UserService 依赖 UserStore 和 Logger
type UserService struct {
    store  UserStore
    logger Logger
}

// 通过构造函数注入依赖
func NewUserService(store UserStore, logger Logger) *UserService {
    return &UserService{
        store:  store,
        logger: logger,
    }
}

// 使用依赖
func (s *UserService) GetUser(id int) (*User, error) {
    s.logger.Log("Getting user " + strconv.Itoa(id))
    return s.store.GetUser(id)
}
```

#### 方式 2：字段注入

```go
package users

type UserService struct {
    store  UserStore
    logger Logger
}

// 直接设置字段
func (s *UserService) SetStore(store UserStore) {
    s.store = store
}

func (s *UserService) SetLogger(logger Logger) {
    s.logger = logger
}
```

### 构造函数注入 vs 字段注入

| 特性 | 构造函数注入 | 字段注入 |
|------|-------------|---------|
| **必需性** | 编译时强制 | 可能忘记设置 |
| **不可变** | 字段可以是私有的 | 字段必须是公开的 |
| **清晰** | 一目了然 | 需要查看更多代码 |
| **灵活性** | 需要提供所有依赖 | 可以逐步设置 |

> ⚠️ **推荐使用构造函数注入**，因为它更安全、更清晰。

### 完整示例

```go
package main

import (
    "fmt"
)

// 定义接口

type Logger interface {
    Log(msg string)
}

type UserStore interface {
    GetUser(id int) (*User, error)
}

// 实现接口

type ConsoleLogger struct{}

func (l *ConsoleLogger) Log(msg string) {
    fmt.Println("[LOG]", msg)
}

type InMemoryUserStore struct {
    users map[int]*User
}

func NewInMemoryUserStore() *InMemoryUserStore {
    return &InMemoryUserStore{
        users: make(map[int]*User),
    }
}

func (s *InMemoryUserStore) GetUser(id int) (*User, error) {
    user, ok := s.users[id]
    if !ok {
        return nil, fmt.Errorf("user not found")
    }
    return user, nil
}

// 使用依赖

type User struct {
    ID   int
    Name string
}

type UserService struct {
    store  UserStore
    logger Logger
}

func NewUserService(store UserStore, logger Logger) *UserService {
    return &UserService{
        store:  store,
        logger: logger,
    }
}

func (s *UserService) GetUser(id int) (*User, error) {
    s.logger.Log(fmt.Sprintf("Getting user ID: %d", id))
    return s.store.GetUser(id)
}

// 主程序

func main() {
    // 创建依赖
    logger := &ConsoleLogger{}
    store := NewInMemoryUserStore()

    // 注入依赖
    userService := NewUserService(store, logger)

    // 使用
    user, err := userService.GetUser(1)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Printf("User: %+v\n", user)
}
```

### 依赖注入的好处

| 好处 | 说明 |
|------|------|
| **易于测试** | 可以注入 mock 对象 |
| **解耦合** | 不依赖具体实现 |
| **灵活性** | 可以替换不同的实现 |
| **可维护性** | 依赖关系清晰 |

---

## 四、其他常见模式

### 1. 错误包装模式

```go
// 多层错误包装
func LoadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }

    config, err := parseConfig(data)
    if err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }

    return config, nil
}

// 检查特定错误
if err != nil {
    var pathErr *os.PathError
    if errors.As(err, &pathErr) {
        // 处理路径错误
    }
}
```

### 2. 资源清理模式

```go
// 使用 defer 确保资源清理
func ProcessFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()  // 确保文件被关闭

    // 处理文件
    // ...

    return nil
}
```

### 3. 并发模式：Worker Pool

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, j)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // 启动 3 个 worker
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // 发送 5 个任务
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    // 收集结果
    for i := 1; i <= 5; i++ {
        <-results
    }
}
```

---

## 五、参考资源（Reference）

### 技能参考

想学习更多 Go 语言模式？

参见技能：`golang-patterns`

这个技能包含了：
- 全面的 Go 语言模式
- 并发编程模式
- 错误处理模式
- 包组织结构建议
- 性能优化技巧

---

## 快速检查清单

在设计 Go 代码时，确保：

- [ ] 使用函数式选项模式配置对象
- [ ] 定义小接口（1-3 个方法）
- [ ] 在使用处定义接口，而非实现处
- [ ] 使用构造函数注入依赖
- [ ] 使用 defer 确保资源清理
- [ ] 用上下文包装错误（使用 `%w`）

---

## 常见问题（FAQ）

**Q: 什么时候应该创建新接口？**

A: 当你需要：
1. 解耦两个模块
2. 编写单元测试需要 mock
3. 让代码更灵活、可测试

**Q: 接口应该放在哪个包？**

A: 接口应该放在**使用它的包**，而不是实现它的包。这叫做"接口隔离原则"。

**Q: 函数式选项模式有什么缺点？**

A: 主要缺点是代码稍微多一点。但带来的灵活性和可读性远超这个缺点。

**Q: 依赖注入和全局变量有什么区别？**

A: 依赖注入从外部接收依赖，全局变量在内部创建。依赖注入更灵活、更易于测试。

**Q: 什么时候使用构造函数注入 vs 字段注入？**

A: 大多数情况下使用构造函数注入。字段注入用于可选依赖或需要动态替换的场景。
