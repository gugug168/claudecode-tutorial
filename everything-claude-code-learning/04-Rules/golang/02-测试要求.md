# Go 测试规范

> 本文件扩展了 [common/testing.md](../common/testing.md)，添加了 Go 语言特定的内容。

## 适用范围

本规则适用于以下文件：
- 所有 `.go` 源文件
- `go.mod` 模块配置文件
- `go.sum` 依赖锁定文件

---

## 一、测试框架（Framework）

### Go 语言的测试工具

Go 语言自带了简单而强大的测试框架：

| 工具/模式 | 用途 | 重要性 |
|----------|------|--------|
| **go test** | 官方测试命令 | 必须掌握 |
| **表驱动测试** | 用数据表组织测试用例 | 推荐使用 |

### 基本测试结构

```go
package math

// 待测试的函数
func Add(a, b int) int {
    return a + b
}

// 测试文件：math_test.go
package math

import "testing"

// 基本测试函数
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Add(2, 3) = %d; want 5", result)
    }
}
```

### 运行测试

```bash
# 运行当前包的所有测试
go test

# 运行所有包的测试
go test ./...

# 运行特定测试
go test -run TestAdd

# 显示详细输出
go test -v

# 显示测试覆盖率
go test -cover
```

---

## 二、表驱动测试（Table-Driven Tests）

### 什么是表驱动测试？

表驱动测试是一种用**数据表**来组织多个测试用例的方法，让你可以用一套测试逻辑验证多组数据。

### 为什么要用表驱动测试？

```go
// ❌ 不好的做法：为每个用例写一个测试函数
func TestAdd_Positive(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("failed")
    }
}

func TestAdd_Negative(t *testing.T) {
    if Add(-2, -3) != -5 {
        t.Error("failed")
    }
}

func TestAdd_Zero(t *testing.T) {
    if Add(0, 0) != 0 {
        t.Error("failed")
    }
}

// ... 要写很多重复的测试函数
```

```go
// ✅ 好的做法：用表驱动测试
func TestAdd(t *testing.T) {
    // 定义测试用例表
    tests := []struct {
        name     string  // 测试用例名称
        a, b     int     // 输入参数
        expected int     // 期望结果
    }{
        {"正数相加", 2, 3, 5},
        {"负数相加", -2, -3, -5},
        {"零的加法", 0, 0, 0},
        {"正负数相加", 5, -3, 2},
        {"大数相加", 1000, 2000, 3000},
    }

    // 遍历测试表
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d",
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

### 表驱动测试的优势

| 优势 | 说明 |
|------|------|
| **减少重复代码** | 一套测试逻辑，多组数据 |
| **易于扩展** | 添加新用例只需在表中增加一行 |
| **清晰的输出** | 每个用例有名称，失败时容易定位 |
| **数据集中** | 所有测试数据一目了然 |

---

## 三、竞态检测（Race Detection）

### 什么是竞态条件？

当两个或多个 goroutine 同时访问同一数据，且至少一个是写操作时，就会发生竞态条件。这会导致不可预测的结果。

### 示例：有竞态条件的代码

```go
// ❌ 有问题的代码
func ParallelIncrement() {
    var counter int
    for i := 0; i < 1000; i++ {
        go func() {
            counter++  // 竞态条件！多个 goroutine 同时写
        }()
    }
}
```

### 使用 `-race` 标志检测竞态

```bash
# 运行测试时检测竞态条件
go test -race ./...

# 运行程序时检测竞态条件
go run -race main.go
```

### 输出示例

如果代码有竞态条件，你会看到类似这样的输出：

```
==================
WARNING: DATA RACE
Read at 0x00... by goroutine 7:
  main.main.func1()
      /path/main.go:10 +0x3d

Previous write at 0x00... by goroutine 6:
  main.main.func1()
      /path/main.go:10 +0x5d
==================
Found 1 data race(s)
```

### 修复竞态条件

```go
// ✅ 使用互斥锁修复
import "sync"

func SafeIncrement() {
    var counter int
    var mu sync.Mutex

    for i := 0; i < 1000; i++ {
        go func() {
            mu.Lock()
            counter++  // 安全了
            mu.Unlock()
        }()
    }
}
```

### 最佳实践

> ⚠️ **始终使用 `-race` 标志运行测试** - 特别是在有并发代码的情况下。

在 CI/CD 流程中，竞态检测应该是必须的：

```bash
# 推荐的测试命令
go test -race -cover ./...
```

---

## 四、测试覆盖率（Coverage）

### 什么是测试覆盖率？

测试覆盖率表示你的代码有多少被测试执行到了。

### 查看覆盖率

```bash
# 查看每个包的覆盖率
go test -cover ./...

# 查看覆盖率详情
go test -coverprofile=coverage.out ./...

# 用浏览器查看覆盖率报告
go tool cover -html=coverage.out
```

### 覆盖率模式

```bash
# 设置模式（set：是否执行，count：执行次数）
go test -covermode=count -coverprofile=coverage.out ./...
```

| 模式 | 说明 |
|------|------|
| **set** | 代码行是否被执行（默认） |
| **count** | 代码行被执行的次数 |
| **atomic** | 原子计数，适合并发测试 |

### 覆盖率目标

建议的目标覆盖率：

- **一般项目**：≥ 70%
- **关键业务逻辑**：≥ 90%
- **工具库**：≥ 80%

> ⚠️ **不要盲目追求 100% 覆盖率** - 重要的是测试质量，而不是数量。

---

## 五、完整示例

### 待测试的代码

```go
package calculator

// Divide 执行除法运算
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}
```

### 测试代码

```go
package calculator

import (
    "testing"
)

func TestDivide(t *testing.T) {
    tests := []struct {
        name        string
        a, b        float64
        expected    float64
        expectError bool
    }{
        {"正常除法", 10, 2, 5, false},
        {"除以小数", 5, 0.5, 10, false},
        {"除以零", 5, 0, 0, true},
        {"负数除法", -10, 2, -5, false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := Divide(tt.a, tt.b)

            if tt.expectError {
                if err == nil {
                    t.Error("expected error but got none")
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if result != tt.expected {
                    t.Errorf("Divide(%f, %f) = %f; want %f",
                        tt.a, tt.b, result, tt.expected)
                }
            }
        })
    }
}
```

### 运行测试

```bash
# 运行测试（竞态检测 + 覆盖率）
go test -race -cover -v ./...
```

---

## 六、参考资源（Reference）

### 技能参考

想学习更多 Go 语言测试模式？

参见技能：`golang-testing`

这个技能包含了：
- 详细的测试模式和辅助函数
- Mock 和测试替身技术
- 基准测试（Benchmark）
- 示例测试（Example）
- 子测试和并行测试

---

## 快速检查清单

在提交 Go 代码前，确保：

- [ ] 所有测试通过：`go test ./...`
- [ ] 竞态检测通过：`go test -race ./...`
- [ ] 覆盖率达到要求：`go test -cover ./...`
- [ ] 使用表驱动测试组织多个用例
- [ ] 测试用例命名清晰，描述准确

---

## 常见问题（FAQ）

**Q: 什么时候应该使用表驱动测试？**

A: 当你有多个相似的测试用例时，应该使用表驱动测试。它可以大大减少重复代码。

**Q: `-race` 标志会让测试变慢吗？**

A: 是的，竞态检测会使测试变慢 5-10 倍。因此，通常在开发时使用，生产环境可以关闭。

**Q: 测试覆盖率多少才算够？**

A: 这取决于项目类型。关键业务逻辑应该有更高的覆盖率。但记住，测试质量比数量更重要。

**Q: 如何测试并发代码？**

A: 使用 `-race` 标志检测竞态条件，使用 `sync.WaitGroup` 或 channel 控制 goroutine，确保测试的确定性。

**Q: 测试文件应该放在哪里？**

A: 测试文件应该和被测试的文件放在同一个包中，文件名以 `_test.go` 结尾。例如：`math.go` 的测试文件是 `math_test.go`。
