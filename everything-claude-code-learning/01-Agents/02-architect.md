# Architect（架构设计代理）

## 一句话总结
Architect 是一个软件架构专家，当你要设计新系统、做大重构、或做技术决策时，它会帮你分析权衡、推荐最佳实践、规划系统演进路线。

---

## 它是什么？（小白视角）

### 用一个比喻来理解

想象你要建一座城市：

- **没有 Architect**：随意盖房子，路修到哪里算哪里，最后变成一团乱麻
- **有 Architect**：先有城市规划师设计道路网络、划分功能区、预留扩展空间

**Architect 就是那个"城市规划师"**，它帮你从全局视角设计系统结构，确保系统可扩展、可维护。

### Planner 和 Architect 的区别

| 角色 | 关注点 | 产出 |
|------|--------|------|
| Planner | "怎么做这个功能" | 具体的实施步骤 |
| Architect | "系统应该长什么样" | 架构图、技术选型、权衡分析 |

---

## 工作原理

```
架构需求 ──→ Architect 代理 ──→ 分析现状
    │                               │
    │                               ↓
    │                          收集需求
    │                               │
    │                               ↓
    │                          设计提案
    │                               │
    │                               ↓
    └───────────────←────────── 权衡分析
```

### 架构审查流程

1. **现状分析**
   - 审查现有架构
   - 识别模式和约定
   - 记录技术债务
   - 评估扩展性限制

2. **需求收集**
   - 功能需求
   - 非功能需求（性能、安全、扩展性）
   - 集成点
   - 数据流需求

3. **设计提案**
   - 高层架构图
   - 组件职责
   - 数据模型
   - API契约
   - 集成模式

4. **权衡分析**
   - 优点：好处和优势
   - 缺点：缺点和限制
   - 替代方案：考虑过的其他选项
   - 决策：最终选择及理由

---

## 配置详解

```yaml
---
name: architect                                    # 代理名称
description: Software architecture specialist...   # 描述
tools: ["Read", "Grep", "Glob"]                   # 只读工具
model: opus                                        # 使用最强模型
---
```

---

## 架构原则

### 1. 模块化与关注点分离
- 单一职责原则
- 高内聚、低耦合
- 组件间清晰的接口
- 独立可部署

### 2. 可扩展性
- 支持水平扩展
- 尽可能无状态设计
- 高效的数据库查询
- 缓存策略
- 负载均衡考虑

### 3. 可维护性
- 清晰的代码组织
- 一致的模式
- 完整的文档
- 易于测试
- 简单易懂

### 4. 安全性
- 纵深防御
- 最小权限原则
- 边界输入验证
- 默认安全
- 审计追踪

### 5. 性能
- 高效算法
- 最小化网络请求
- 优化的数据库查询
- 适当的缓存
- 懒加载

---

## 常见架构模式

### 前端模式

| 模式 | 说明 |
|------|------|
| 组件组合 | 用简单组件构建复杂UI |
| 容器/展示者 | 分离数据逻辑和展示 |
| 自定义Hooks | 可复用的有状态逻辑 |
| Context全局状态 | 避免prop drilling |
| 代码分割 | 懒加载路由和重型组件 |

### 后端模式

| 模式 | 说明 |
|------|------|
| 仓库模式 | 抽象数据访问 |
| 服务层 | 业务逻辑分离 |
| 中间件模式 | 请求/响应处理 |
| 事件驱动架构 | 异步操作 |
| CQRS | 读写分离 |

### 数据模式

| 模式 | 说明 |
|------|------|
| 规范化数据库 | 减少冗余 |
| 反规范化读优化 | 优化查询 |
| 事件溯源 | 审计追踪和可重放 |
| 缓存层 | Redis, CDN |
| 最终一致性 | 分布式系统 |

---

## 架构决策记录（ADR）

对于重要的架构决策，Architect 会帮你创建ADR：

```markdown
# ADR-001: 使用Redis存储语义搜索向量

## 背景
需要存储和查询1536维的嵌入向量用于语义市场搜索。

## 决策
使用支持向量搜索的Redis Stack。

## 影响

### 积极
- 快速向量相似度搜索 (<10ms)
- 内置KNN算法
- 部署简单
- 10万向量内性能良好

### 消极
- 内存存储（大数据集成本高）
- 无集群时单点故障
- 仅支持余弦相似度

### 考虑过的替代方案
- **PostgreSQL pgvector**: 更慢，但持久存储
- **Pinecone**: 托管服务，成本更高
- **Weaviate**: 功能更多，设置更复杂

## 状态
已采纳

## 日期
2025-01-15
```

---

## 系统设计检查清单

### 功能需求
- [ ] 用户故事已记录
- [ ] API契约已定义
- [ ] 数据模型已指定
- [ ] UI/UX流程已映射

### 非功能需求
- [ ] 性能目标已定义（延迟、吞吐量）
- [ ] 可扩展性需求已指定
- [ ] 安全需求已识别
- [ ] 可用性目标已设定（正常运行时间%）

### 技术设计
- [ ] 架构图已创建
- [ ] 组件职责已定义
- [ ] 数据流已记录
- [ ] 集成点已识别
- [ ] 错误处理策略已定义
- [ ] 测试策略已规划

### 运维
- [ ] 部署策略已定义
- [ ] 监控和告警已规划
- [ ] 备份和恢复策略
- [ ] 回滚计划已记录

---

## 红旗警告

Architect 会警惕这些架构反模式：

| 反模式 | 说明 |
|--------|------|
| 大泥球 | 没有清晰结构 |
| 金锤子 | 用同一个方案解决所有问题 |
| 过早优化 | 太早优化 |
| 非我所创 | 拒绝现有解决方案 |
| 分析瘫痪 | 过度规划，不够建设 |
| 魔法 | 不清晰、无文档的行为 |
| 紧耦合 | 组件过度依赖 |
| 上帝对象 | 一个类/组件做所有事 |

---

## 实际案例：AI SaaS平台架构

```markdown
### 当前架构
- **前端**: Next.js 15 (Vercel/Cloud Run)
- **后端**: FastAPI 或 Express (Cloud Run/Railway)
- **数据库**: PostgreSQL (Supabase)
- **缓存**: Redis (Upstash/Railway)
- **AI**: Claude API 结构化输出
- **实时**: Supabase 订阅

### 关键设计决策
1. **混合部署**: Vercel(前端) + Cloud Run(后端) 性能最优
2. **AI集成**: 使用Pydantic/Zod结构化输出确保类型安全
3. **实时更新**: Supabase订阅实现实时数据
4. **不可变模式**: 展开运算符实现可预测状态
5. **多小文件**: 高内聚，低耦合

### 扩展性计划
| 用户规模 | 策略 |
|----------|------|
| 1万用户 | 当前架构足够 |
| 10万用户 | 添加Redis集群，静态资源CDN |
| 100万用户 | 微服务架构，读写分离数据库 |
| 1000万用户 | 事件驱动架构，分布式缓存，多区域 |
```

---

## 使用方法

### 通过命令调用
```bash
# 通常与 /plan 命令配合使用
/plan "设计一个新的微服务架构"
```

### 或者直接描述需求
```
我需要设计一个支持百万用户的实时聊天系统，应该怎么架构？
```

---

## 注意事项

1. **使用 opus 模型** - 架构决策需要深度思考
2. **记录决策** - 创建ADR记录重要决策及原因
3. **考虑演进** - 设计时考虑未来扩展
4. **平衡取舍** - 没有完美方案，只有最适合的权衡
5. **保持简单** - 过度设计是架构的大敌

---

## 相关代理

- **planner** - 获得架构设计后，制定具体实施计划
- **code-reviewer** - 确保实现符合架构设计
- **security-reviewer** - 审查架构的安全性
