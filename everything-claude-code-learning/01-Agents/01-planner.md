# Planner（功能规划代理）

## 一句话总结
Planner 是一个专门帮你制定实施计划的代理，当你想要添加新功能或重构代码时，它会帮你分析需求、分解步骤、识别风险，生成一份详细的"施工图纸"。

---

## 它是什么？（小白视角）

### 用一个比喻来理解

想象你要盖一栋房子：

- **没有 Planner**：你直接开始砌砖，砌到一半发现忘了打地基，或者电线管道没预留
- **有 Planner**：先有一位建筑师帮你画好蓝图，标注每个步骤、材料、注意事项

**Planner 就是那个"建筑师"**，它在你动手写代码之前，先帮你把整个计划想清楚。

### 什么时候需要它？

- 你说"我想添加用户认证功能"
- 你说"我想重构这个模块"
- 你说"我想把系统从MySQL迁移到PostgreSQL"
- 任何需要多步骤实现的功能

---

## 工作原理

```
用户请求 ──→ Planner 代理 ──→ 分析代码库
    │                              │
    │                              ↓
    │                         识别依赖和风险
    │                              │
    │                              ↓
    └────────────────←─────── 生成详细实施计划
```

### 规划流程

1. **需求分析** - 完全理解你的需求，必要时提问澄清
2. **架构审查** - 分析现有代码结构，找出受影响的组件
3. **步骤分解** - 把大任务拆成小步骤，每个步骤都有：
   - 具体操作
   - 文件路径
   - 依赖关系
   - 复杂度估计
   - 潜在风险
4. **实施顺序** - 按依赖关系排序，支持增量测试

---

## 配置详解

```yaml
---
name: planner                                    # 代理名称
description: Expert planning specialist...       # 描述：说明什么时候使用
tools: ["Read", "Grep", "Glob"]                 # 可用工具：只读操作
model: opus                                      # 使用最强模型（需要深度思考）
---
```

### 配置项解释

| 配置项 | 值 | 为什么这样设置 |
|--------|-----|----------------|
| name | planner | 代理的唯一标识符 |
| tools | Read, Grep, Glob | 只需要读取和分析代码，不需要修改 |
| model | opus | 规划需要深度思考，使用最强模型 |

---

## 输出格式（计划模板）

Planner 生成的计划长这样：

```markdown
# 实施计划: [功能名称]

## 概述
[2-3句话总结这个功能是做什么的]

## 需求
- [需求1]
- [需求2]

## 架构变更
- [变更1: 文件路径和描述]
- [变更2: 文件路径和描述]

## 实施步骤

### 阶段1: [阶段名称]
1. **[步骤名称]** (文件: path/to/file.ts)
   - 操作: 具体要做什么
   - 原因: 为什么要这样做
   - 依赖: 无 / 需要步骤X
   - 风险: 低/中/高

2. **[步骤名称]** (文件: path/to/file.ts)
   ...

### 阶段2: [阶段名称]
...

## 测试策略
- 单元测试: [要测试的文件]
- 集成测试: [要测试的流程]
- E2E测试: [要测试的用户旅程]

## 风险与缓解措施
- **风险**: [描述]
  - 缓解: [如何解决]

## 成功标准
- [ ] 标准1
- [ ] 标准2
```

---

## 实际案例：添加Stripe订阅计费

这是一个完整的真实案例，展示Planner能生成的详细程度：

```markdown
# 实施计划: Stripe订阅计费

## 概述
添加订阅计费功能，支持免费/专业/企业三档。用户通过Stripe Checkout升级，Webhook事件保持订阅状态同步。

## 需求
- 三个档位: 免费(默认), 专业($29/月), 企业($99/月)
- Stripe Checkout支付流程
- Webhook处理器处理订阅生命周期事件
- 基于订阅档位的功能门控

## 架构变更
- 新表: `subscriptions` (user_id, stripe_customer_id, stripe_subscription_id, status, tier)
- 新API路由: `app/api/checkout/route.ts` — 创建Stripe Checkout会话
- 新API路由: `app/api/webhooks/stripe/route.ts` — 处理Stripe事件
- 新中间件: 检查订阅档位，门控功能
- 新组件: `PricingTable` — 显示档位和升级按钮

## 实施步骤

### 阶段1: 数据库和后端 (2个文件)
1. **创建订阅迁移** (文件: supabase/migrations/004_subscriptions.sql)
   - 操作: 创建subscriptions表和RLS策略
   - 原因: 服务端存储计费状态，永远不信任客户端
   - 依赖: 无
   - 风险: 低

2. **创建Stripe Webhook处理器** (文件: src/app/api/webhooks/stripe/route.ts)
   - 操作: 处理 checkout.session.completed, customer.subscription.updated, customer.subscription.deleted 事件
   - 原因: 保持订阅状态与Stripe同步
   - 依赖: 步骤1 (需要subscriptions表)
   - 风险: 高 — Webhook签名验证很关键

### 阶段2: Checkout流程 (2个文件)
3. **创建Checkout API路由** (文件: src/app/api/checkout/route.ts)
   - 操作: 创建Stripe Checkout会话，包含price_id和success/cancel URL
   - 原因: 服务端创建会话防止价格篡改
   - 依赖: 步骤1
   - 风险: 中 — 必须验证用户已登录

4. **构建定价页面** (文件: src/components/PricingTable.tsx)
   - 操作: 显示三个档位的功能对比和升级按钮
   - 原因: 用户升级界面
   - 依赖: 步骤3
   - 风险: 低

### 阶段3: 功能门控 (1个文件)
5. **添加基于档位的中间件** (文件: src/middleware.ts)
   - 操作: 检查受保护路由的订阅档位，重定向免费用户
   - 原因: 服务端强制执行档位限制
   - 依赖: 步骤1-2 (需要订阅数据)
   - 风险: 中 — 必须处理边界情况 (过期, 欠费)

## 测试策略
- 单元测试: Webhook事件解析, 档位检查逻辑
- 集成测试: Checkout会话创建, Webhook处理
- E2E测试: 完整升级流程 (Stripe测试模式)

## 风险与缓解措施
- **风险**: Webhook事件乱序到达
  - 缓解: 使用事件时间戳, 幂等更新
- **风险**: 用户升级但Webhook失败
  - 缓解: 轮询Stripe作为备用, 显示"处理中"状态

## 成功标准
- [ ] 用户可通过Stripe Checkout从免费升级到专业版
- [ ] Webhook正确同步订阅状态
- [ ] 免费用户无法访问专业版功能
- [ ] 降级/取消正常工作
- [ ] 所有测试通过，覆盖率80%+
```

---

## 使用方法

### 通过命令调用
```bash
/plan "添加用户认证功能"
```

### 或者直接描述需求
```
我想添加一个文件上传功能，支持图片和PDF，需要限制大小和类型
```

Planner 会自动被触发，生成详细的实施计划。

---

## 最佳实践

1. **具体明确** - 使用精确的文件路径、函数名、变量名
2. **考虑边界情况** - 想想错误场景、空值、空状态
3. **最小化变更** - 优先扩展现有代码，而不是重写
4. **保持模式一致** - 遵循项目现有约定
5. **支持测试** - 结构化变更使其易于测试
6. **增量思考** - 每个步骤都应该可验证
7. **记录决策** - 解释"为什么"，不只是"做什么"

---

## 分阶段策略

当功能很大时，Planner 会把它分成可独立交付的阶段：

| 阶段 | 目标 | 说明 |
|------|------|------|
| 阶段1 | 最小可行 | 能提供价值的最小切片 |
| 阶段2 | 核心体验 | 完整的正常流程 |
| 阶段3 | 边界情况 | 错误处理、边界情况、打磨 |
| 阶段4 | 优化 | 性能、监控、分析 |

**重要**: 每个阶段都应该可以独立合并。避免需要所有阶段完成才能工作的计划。

---

## 红旗检查清单

Planner 会检查这些危险信号：

- [ ] 大函数 (>50行)
- [ ] 深嵌套 (>4层)
- [ ] 重复代码
- [ ] 缺少错误处理
- [ ] 硬编码值
- [ ] 缺少测试
- [ ] 性能瓶颈
- [ ] 没有测试策略的计划
- [ ] 没有明确文件路径的步骤
- [ ] 无法独立交付的阶段

---

## 注意事项

1. **Planner 不写代码** - 它只负责规划，实际实现由其他代理或你来完成
2. **需要 opus 模型** - 因为规划需要深度思考，会消耗更多Token
3. **可以追问** - 如果需求不清晰，Planner 会向你提问
4. **保持灵活性** - 计划不是死的，可以根据实际情况调整

---

## 相关代理

- **architect** - 如果需要更深入的架构设计决策
- **tdd-guide** - 获得计划后，用TDD方式实现
- **code-reviewer** - 实现后进行代码审查
